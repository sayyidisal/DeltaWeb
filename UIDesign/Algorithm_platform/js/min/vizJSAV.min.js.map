{"version":3,"sources":["vizJSAV.js"],"names":["vizJSAV","divID","data","jsonContent","container","$","findObj","varName","pointerName","depth","depthStr","depthNo","match","isNaN","i","jsavObjDict","strToArray","str","result","slice","length","optStack","token","push","pop","trim","strToDict","replace","labelPointer","name","jsavObj","pointer","av","currentStat","glbFlags","u","n","c","indexColor","nColor","cColor","bColor","edgeColor","matrixHeaderColor","uColor","graphColor","RED","BLUE","GRAY","WHITE","YELLOW","GREEN","BLACK","DATATYPES","OBJTYPES","current_content","current_line","glbpointerList","glbpointerParamList","avDepthDict","divDepthList","prototype","animate","statementNo","statementLabel","depthList","hide","nameDict","varList","variableList","type","key","indexOf","preLayerCount","curLayerCount","Object","keys","remove","splice","layer","append","avObj","JSAV","containerWidth","width","padding","singleLayerWidth","css","j","variable","jsavObjList","this","plotVar","pointerIndex","pointerDepth","message","text","tempPointer","addClass","addPointer","pointerList","pointerVar","pointerObj","labelObj","pointerVariable","varFlag","index","currentAv","refreshFlag","className","parseInt","opts","listType","targetIndex","anchor","myAnchor","setCSSByClass","objclass","cssStr","objs","document","getElementsByClassName","arrayHighlight","array","indices","highlight","arrayUnhighlight","unhighlight","linkedListHighlight","linkedList","get","linkedListUnhighlight","avVar","varType","varPointer","varValue","value","statusStr","code","lineNumbers","background-color","clearDictFlags","clearListFlags","clearLinkedListFlags","clearMatrixFlags","clearStringMatrixFlags","clearBTreeFlags","clearHeapFlags","clearDisjoinSetFlags","avLabel","avVarList","label","parseDict","parseList","layout","indexed","parseLinkedList","parseMatrix","parseStringMatrix","parseGraph","directed","parseBTree","parseHeap","parseDisjointSet","flagsList","flags","varIndex","options","valueList","ds","mouseenter","mouseleave","matrixArr","matrix","style","flagsArr","topheader","leftheader","hasHeader","edgesArr","edges","topheaderObj","extend","leftheaderObj","map","newMatrixObj","newMatrixArr","a","b","d","stroke","addEdge","indexKey","flagsDict","count","valDict","Array","firstRow","secondRow","valList","list","addLast","vertexList","V","edgeList","E","graph","vertexDict","vertex","color","toUpperCase","node","addNode","start","end","weight","root","clearBTreeNodeColor","left","right","treeType","rbArr","tree","binarytree","varFlags","rbValue","tempLast","nodeStack","nodeCount","newNode","border-color","border-width","valArr","nodeList","parentIndex","varible","flagDict","nodeDict","recursive","addChild","edgeToParent"],"mappings":"AAqDA,QAASA,SAAQC,EAAMC,GACpBC,YAAcD,EACdE,UAAYC,EAAE,IAAIJ,GA+KrB,QAASK,SAAQC,EAASC,EAAaC,GAMnC,GACIC,GADAC,EAAUF,EAAMG,MAAM,OAAO,EAEjC,IAAIC,MAAMF,GACN,MAAO,EAIX,KAAK,GAAIG,GAAEH,EAASG,EAAG,EAAGA,IAEtB,GADAJ,EAAW,SAAWI,EAClBN,IAAeO,aAAYL,KACzBF,GAAeD,GAAWO,GAAKH,GAAaH,GAAeD,GAAU,CACvE,GAA6C,MAAzCQ,YAAYL,GAAUF,GAAa,GACnC,QAEJ,OAAOM,GAGf,MAAO,GAwIX,QAASE,YAAWC,GAChB,GAAIC,KAEJ,IAAc,KAAVD,EAAI,IAA8B,KAAjBA,EAAIE,MAAM,IAC3B,MAAO,KAGX,KAAI,GAAIL,GAAE,EAAGA,EAAEG,EAAIG,OAAO,EAAGN,IACzB,OAAQG,EAAIH,IACR,IAAK,IAED,GAAIO,IAAY,KAAMC,EAAQ,GAE9B,KADAR,IACyB,GAAnBO,EAASD,QAAY,CACvB,GAAIN,GAAKG,EAAIG,OAAQ,EACjB,MAAO,KAEG,MAAVH,EAAIH,GACJO,EAASE,KAAKF,GACC,KAAVJ,EAAIH,IACTO,EAASG,MAEbF,GAASL,EAAIH,KAEjBI,EAAOK,KAAKP,WAAWM,IAEvBR,GACA,MACJ,KAAK,IACD,MAAO,KACX,SAEI,IADA,GAAIQ,GAAQ,GACI,KAAVL,EAAIH,IAAuB,KAAVG,EAAIH,IAAuB,KAAVG,EAAIH,IAAaA,EAAEG,EAAIG,OAAO,GAClEE,GAASL,EAAIH,IAEjBI,GAAOK,KAAKD,EAAMG,QAEJ,KAAVR,EAAIH,IACJA,IAKhB,MAAOI,GAQX,QAASQ,WAAUT,GAIfA,EAAMA,EAAIU,QAAQ,MAAO,KAgX7B,QAASC,cAAaC,EAAMC,GACxB,GAAIC,GAAUC,GAAGD,QAAQF,EAAMC,EAC/B,OAAOC,GA3yBX,GAAI5B,gBAAkB8B,YAClBC,UAAYC,EAAK,EAAGC,EAAK,EAAGC,EAAK,GAGjCC,WAAa,qBACbC,OAAS,qBACTC,OAAS,qBACTC,OAAS,MACTC,UAAY,qBACZC,kBAAoB,mBACpBC,OAAS,QAETC,YACAC,IAAO,qBACPC,KAAQ,qBACRC,KAAQ,qBACRC,MAAS,qBACTC,OAAU,qBACVC,MAAS,qBACTC,MAAS,gBAGTC,WAAa,QAAS,QAAS,QAAS,QAAS,aAAc,SAAU,eAAgB,MAAO,QAAS,QACrG,UAAW,mBAAoB,UAAW,SAAU,gBAAiB,mBAAoB,cACzF,MAAO,MAAO,OAAQ,QAAS,YACnCC,UAAY,QAAS,QAAS,QAAS,QAAS,aAAc,SAAU,eAAgB,MAAO,QAAS,QACpG,UAAW,mBAAoB,UAAW,SAAU,gBAAiB,mBAAoB,eAE7FtB,GACAjB,eACAwC,gBAAiBC,aACjBC,kBACAC,uBACAC,eACAC,gBACAxD,SA8BJJ,SAAQ6D,UAAUC,QAAU,SAASC,GACjC,GAAIC,GAAgB,aAAaD,CAEjC,IADA9B,YAAc+B,EACRA,IAAkB7D,aAAxB,CAIA,GAAI8D,GAAY9D,YAAY6D,GAAsB,IAClDT,iBAAkBpD,YAAY6D,GAAiC,gBAC/DR,aAAerD,YAAY6D,GAA8B,aAEzDN,sBAEA,KAAK,GAAI5C,GAAE,EAAGA,EAAE2C,eAAerC,OAAQN,IACnC2C,eAAe3C,GAAGoD,MAEtBT,kBAEA,IAAIU,KAGJ,KAAK,GAAI1D,KAASwD,GAAU,CAIxB,IAAK,GAHDG,MAEAC,EAAeJ,EAAUxD,GACpBK,EAAE,EAAGA,EAAEuD,EAAajD,OAAQN,IAAI,CACrC,GAAIP,GAAU8D,EAAavD,GAAGe,IAChBwC,GAAavD,GAAGwD,IAC1BF,GAAQ7C,KAAKhB,GAErB4D,EAAS1D,GAAS2D,EAItB,IAAK,GAAI3D,KAASM,aACd,IAAK,GAAIwD,KAAOxD,aAAYN,GACxB,GAAMA,IAAS0D,IAQX,GAAoC,IAAhCA,EAAS1D,GAAO+D,QAAQD,GAAW,CACnC,IAAK,GAAIzD,GAAE,EAAGA,EAAEC,YAAYN,GAAO8D,GAAKnD,OAAQN,IACV,MAA9BC,YAAYN,GAAO8D,GAAKzD,IACxBC,YAAYN,GAAO8D,GAAKzD,GAAGoD,aAG5BnD,aAAYN,GAAO8D,QAdT,CACrB,IAAK,GAAIzD,GAAE,EAAGA,EAAEC,YAAYN,GAAO8D,GAAKnD,OAAQN,IACV,MAA9BC,YAAYN,GAAO8D,GAAKzD,IACxBC,YAAYN,GAAO8D,GAAKzD,GAAGoD,aAG5BnD,aAAYN,GAAO8D,GAetC,GAAIE,GAAgBb,aAAaxC,OAC9BsD,EAAgBC,OAAOC,KAAKX,GAAW7C,MAG1C,IAAIqD,EAAgBC,EAAc,CAC9B,IAAK,GAAI5D,GAAI4D,EAAmBD,EAAJ3D,EAAmBA,UACpC6C,aAAY,UAAU7C,EAAE,IAC/B8C,aAAa9C,GAAG+D,QAGpBjB,cAAakB,OAAOJ,EAAeD,EAAcC,GAGrD,GAAoBA,EAAhBD,EACA,IAAK,GAAI3D,GAAI2D,EAAmBC,EAAJ5D,EAAmBA,IAAK,CAChD,GAAIiE,GAAQ1E,EAAE,kBAAkBS,EAAE,GAAG,8DAA8DA,EAAE,GAAG,gBACxGV,WAAU4E,OAAOD,EACjB,IAAIE,GAAQ,GAAIC,MAAKH,EAErBpB,aAAY,UAAY7C,EAAI,IAAMmE,EAClCrB,aAAa9C,GAAKiE,EAM1B,GAAII,GAAiB/E,UAAUgF,OAC3BC,SAAU,GACVC,kBAAoBH,EAAgB,EAAEE,QAAQX,GAAgBA,EAClErE,EAAE,eAAekF,IAAI,QAASD,kBAC9BjF,EAAE,eAAekF,IAAI,eAAgBF,SACrChF,EAAE,eAAekF,IAAI,gBAAiBF,QAGtC,KAAK,GAAI5E,KAASwD,GAAU,CAElBxD,IAASM,eACXA,YAAYN,MAIhB,KAAK,GADD4D,GAAeJ,EAAUxD,GACpB+E,EAAE,EAAGA,EAAEnB,EAAajD,OAAQoE,IAAI,CACpC,GAAIC,GAAWpB,EAAamB,EAC5B,IAAgB,MAAZC,EAAiB,CACjB,GAAIlF,GAAUkF,EAAS5D,IAkBN4D,GAAS1D,OAC1BC,IAAK2B,YAAYlD,EAGd,IAAIiF,GAAcC,KAAKC,QAAQH,EAAUhF,EACzCM,aAAYN,GAAOF,GAAWmF,IAS9C,IAAK,GAAI5E,GAAE,EAAGA,EAAE4C,oBAAoBtC,OAAQN,IAExC,GAAiC,gBAA7B4C,oBAAoB5C,GAAG,GAAqB,CAG5C,GAAI+E,GAAenC,oBAAoB5C,GAAG,GAAU,MAChDgF,EAAepC,oBAAoB5C,GAAG,GAAU,MAChDiF,EAAUrC,oBAAoB5C,GAAG,GAAGkF,MACxCD,IAAW,OAASD,EAAe,IAAMpC,oBAAoB5C,GAAG,GAC5C,MAAhB+E,GAA8C,GAAtBA,EAAazE,SACrC2E,GAAW,YAAaF,GAG5BnC,oBAAoB5C,GAAG,GAAGkF,KAAKD,OAC9B,CACD,GAAIE,GAActC,YAAYD,oBAAoB5C,GAAG,IAAIiB,QAAQ2B,oBAAoB5C,GAAG,GAAI4C,oBAAoB5C,GAAG,GAAI4C,oBAAoB5C,GAAG,GAC9ImF,GAAYC,SAASxC,oBAAoB5C,GAAG,IAC5C2C,eAAelC,KAAK0E,MAyChCjG,QAAQ6D,UAAUsC,WAAa,SAASV,EAAUhF,GAC9C,GAAI2F,GAAcX,EAAS1D,QACvBxB,EAAUkF,EAAS5D,KACnBrB,EAAc4F,EAAY,GAC1BP,EAAeO,EAAY,GAE3BzF,EAAUL,QAAQC,EAASC,EAAaC,EAE5C,IAAe,IAAXE,EAAe,CACf,GAAyD,GAArDI,YAAY,SAASJ,GAASH,GAAaY,OAC3C,MAAO,KAQX,KAAK,GADDiF,GALAC,EAAavF,YAAY,SAASJ,GAASH,GAAa,GACxD+F,EAAWxF,YAAY,SAASJ,GAASH,GAAa,GAGtD6D,EAAelE,YAAY8B,aAAmB,KAAE,SAAWtB,GAEtD6E,EAAI,EAAGA,EAAInB,EAAajD,OAAQoE,IAAK,CAC1C,GAAIgB,GAAkBnC,EAAamB,EAC/BgB,GAAgB3E,MAAQrB,IACxB6F,EAAaG,GAIrB,GAAIf,EAASgB,SAAWvE,SAAY,EAAE,CAChB,MAAdoE,GACAA,EAAWpC,OAEC,MAAZqC,GACAA,EAASrC,OAIO,MAAhB2B,GAA+C,GAAvBA,EAAazE,SACrCiF,EAAWK,MAAQb,GAED,MAAlBJ,EAASiB,OAA0C,GAAzBjB,EAASiB,MAAMtF,SACzCiF,EAAWK,MAAQjB,EAASiB,MAGhC,IAAIC,GAAY3E,EAChBA,IAAK2B,YAAY,SAAShD,GAE1BI,YAAY,SAAWJ,GAASH,GAAemF,KAAKC,QAAQS,EAAY,SAAW1F,GAEnFqB,GAAK2E,EAELL,EAAavF,YAAY,SAAWJ,GAASH,GAAa,GAC1D+F,EAAWxF,YAAY,SAAWJ,GAASH,GAAa,EAGxD,KAAK,GAAIM,GAAE,EAAGA,EAAE4C,oBAAoBtC,OAAQN,IACpC4C,oBAAoB5C,GAAG,IAAM,SAASH,GAAW+C,oBAAoB5C,GAAG,IAAMN,IAC7C,gBAA7BkD,oBAAoB5C,GAAG,GACvB4C,oBAAoB5C,GAAG,GAAKyF,GAE5B7C,oBAAoB5C,GAAG,GAAKwF,EAC5B5C,oBAAoB5C,GAAG,GAAW,OAAI,kBAO9B,OAAhB+E,GAA+C,GAAvBA,EAAazE,SACrCiF,EAAWK,MAAQb,GAED,MAAlBJ,EAASiB,OAA0C,GAAzBjB,EAASiB,MAAMtF,SACzCiF,EAAWK,MAAQjB,EAASiB,OAEhCf,KAAKiB,YAAYP,EAAY,SAAW1F,EAG5C,IAAuDkG,GAA1CH,EAAQI,SAASjB,GAAekB,IAGtB,UAAnBV,EAAW/B,MAAsC,QAAnB+B,EAAW/B,IAI7C,IAAI0C,IAAY,QAAS,OAAQ,QAAS,QAAS,MAAO,QA2B1D,OA1BInG,OAAM6F,IAA+C,IAArCM,EAASxC,QAAQ6B,EAAW/B,OACJ,IAArC0C,EAASxC,QAAQ6B,EAAW/B,QAC3B9D,GAAe,IAAIkG,EAAM,KAK7BK,GAAQtG,MAASA,EAAOiG,MAASb,GACjCgB,EAAY,eAIZnD,oBAAoBnC,MAAMkE,EAAS5D,KAAM0E,EAAUQ,EAAMF,EAAW,SAASlG,EAASH,MAGtFuG,GAAQE,YAAeP,EAAOQ,OAAU,WAAYC,SAAY,iBAGhEN,EAAY,iBAIZnD,oBAAoBnC,MAAMkE,EAAS5D,KAAMyE,EAAYS,EAAMF,EAAW,SAASlG,EAASH,KAIrF,KAEX,MAAO,OAgFXR,QAAQ6D,UAAUuD,cAAc,SAASC,EAASC,GAE9C,IAAK,GADDC,GAAOC,SAASC,uBAAuBJ,GAClCvG,EAAE,EAAGA,EAAEyG,EAAKnG,OAAON,IACxByG,EAAKzG,GAAGyE,IAAI+B,IAKpBtH,QAAQ6D,UAAU6D,eAAe,SAASC,EAAOC,GAC7CD,EAAME,UAAUD,IAEpB5H,QAAQ6D,UAAUiE,iBAAiB,SAASH,EAAOC,GAC/CD,EAAMI,YAAYH,IAEtB5H,QAAQ6D,UAAUmE,oBAAoB,SAASC,EAAYvB,GACvDuB,EAAWC,IAAIxB,GAAOmB,aAE1B7H,QAAQ6D,UAAUsE,sBAAsB,SAASF,EAAYvB,GACzDuB,EAAWC,IAAIxB,GAAOqB,eAQ1B/H,QAAQ6D,UAAU+C,YAAc,SAASnB,EAAUhF,GAE/C,GAII2H,GAJA7H,EAAUkF,EAAS5D,KACnBwG,EAAU5C,EAASnB,KACnBmC,EAAUhB,EAASgB,QACnB6B,EAAa7C,EAAS1D,OAE1B,IAAmC,MAA/BhB,YAAYN,GAAOF,IAA0D,GAAtCQ,YAAYN,GAAOF,GAASa,SAIvEgH,EAAQrH,YAAYN,GAAOF,GAAS,GAGlB,MAAd+H,GAA2C,GAArBA,EAAWlH,QAKrC,OAAQiH,GACJ,IAAK,MAAO,IAAK,MAAO,IAAK,OAAO,IAAK,QAAQ,IAAK,WAOlDD,EAAMlE,OACNqE,SAAW9C,EAAS+C,KACpB,IAAIC,GAAYJ,EAAU,IAAM9H,EAAQkB,OAAQ,MAAQ8G,QACxDH,GAAQpG,GAAG0G,KAAKD,GAAYE,aAAa,IACrClC,GAAWvE,SAAY,EACvBkG,EAAM7C,IAAI,GAAIqD,mBAAoBpG,SAC7BiE,GAAWvE,SAAY,EAC5BkG,EAAM7C,IAAI,GAAIqD,mBAAoBrG,SAElC6F,EAAM7C,IAAI,GAAIqD,mBAAqBhG,SAEvCwF,EAAMlC,SAAS,aACfnF,YAAYN,GAAOF,GAAS,GAAK6H,CACjC,MACJ,KAAK,QAAQ,IAAK,OACdzC,KAAKkD,eAAeT,EAAO3C,EAC3B,MACJ,KAAK,QAAQ,IAAK,OAAQ,IAAK,MAAM,IAAK,QAAQ,IAAK,QAAQ,IAAK,QAChEE,KAAKmD,eAAeV,EAAO3C,EAC3B,MACJ,KAAK,aACDE,KAAKoD,qBAAqBX,EAAO3C,EACjC,MACJ,KAAK,SACDE,KAAKqD,iBAAiBZ,EAAO3C,EAC7B,MACJ,KAAK,eACDE,KAAKsD,uBAAuBb,EAAO3C,EACnC,MACJ,KAAK,QAAQ,IAAK,UAEd,KACJ,KAAK,SACD,KACJ,KAAK,mBAAmB,IAAK,UACzBE,KAAKuD,gBAAgBd,EAAO3C,EAC5B,MACJ,KAAK,gBAAgB,IAAK,mBACtBE,KAAKwD,eAAef,EAAO3C,EAC3B,MACJ,KAAK,cACDE,KAAKyD,qBAAqBhB,EAAO3C,EACjC,MACJ,KAAK,OACD,KACJ,SACI2C,EAAMlE,OACNqE,SAAW9C,EAAS+C,KACpB,IAAIF,GAAa7C,EAAS1D,OAC1B,IAAkB,MAAduG,GAAsBA,EAAWlH,OAAS,EAC1CgH,EAAQzC,KAAKQ,WAAWV,EAAUhF,OAChC,CACF,GAAIgI,EAEAA,GADW,MAAXJ,EACYA,EAAU,IAAM9H,EAAQkB,OAAS,MAAQ8G,SAEzChI,EAAQkB,OAAS,KAAO8G,SAExCH,EAAQpG,GAAG0G,KAAKD,GAAYE,aAAa,IACrClC,GAAWvE,SAAY,EACvBkG,EAAM7C,IAAI,GAAIqD,mBAAoBpG,SAC3BiE,GAAWvE,SAAY,EAC9BkG,EAAM7C,IAAI,GAAIqD,mBAAoBrG,SAElC6F,EAAM7C,IAAI,GAAIqD,mBAAoBhG,SAEtCwF,EAAMlC,SAAS,UAEnBnF,YAAYN,GAAOF,GAAS,GAAK6H,IAS7CpI,QAAQ6D,UAAU+B,QAAU,SAASH,EAAUhF,GAG3C,GAGI8H,GACAH,EACAiB,EALAhB,EAAU5C,EAASnB,KACnB/D,EAAUkF,EAAS5D,KACnB4E,EAAUhB,EAASgB,QAInB6C,EAAYvI,YAAYN,GAAOF,EAInC,IAAiB,MAAb+I,EACA,IAAK,GAAIxI,GAAE,EAAGA,EAAEwI,EAAUlI,OAAQN,IACV,MAAhBwI,EAAUxI,IACVwI,EAAUxI,GAAGoD,MAOzB,QAAQmE,GACJ,IAAK,MAAO,IAAK,MAAO,IAAK,OAAO,IAAK,QAAQ,IAAK,WAClDE,EAAW9C,EAAS+C,KACpB,IAAIC,GAAYJ,EAAU,IAAM9H,EAAQkB,OAAQ,MAAQ8G,CACxDH,GAAQpG,GAAG0G,KAAKD,GAAYE,aAAa,IACrClC,GAAWvE,SAAY,EACvBkG,EAAM7C,IAAI,GAAIqD,mBAAoBpG,SAC7BiE,GAAWvE,SAAY,GAC5BkG,EAAM7C,IAAI,GAAIqD,mBAAoBrG,SAEtC6F,EAAMlC,SAAS,YACf,MAEJ,KAAK,QAAQ,IAAK,OAEd,GAAIoC,GAAa7C,EAAS1D,OACR,OAAduG,GAAsBA,EAAWlH,OAAS,EAC1CgH,EAAQzC,KAAKQ,WAAWV,EAAUhF,IAElC4I,EAAUrH,GAAGuH,MAAM9D,EAAS5D,MAC5BuG,EAAQzC,KAAK6D,UAAU/D,GACvB2C,EAAMlC,SAAS,SAEnB,MACJ,KAAK,QAAQ,IAAK,QAAS,IAAK,MAAM,IAAK,QAEvC,GAAIoC,GAAa7C,EAAS1D,OACR,SAAduG,GAAwBA,EAAWlH,OAAS,EAC5CgH,EAAQzC,KAAKQ,WAAWV,EAAUhF,IAElC4I,EAAUrH,GAAGuH,MAAM9D,EAAS5D,MAC5BuG,EAAOzC,KAAK8D,UAAUhE,MACtB2C,EAAMlC,SAAS,SAGnB,MACJ,KAAK,QACD,GAAIoC,GAAa7C,EAAS1D,OACR,OAAduG,GAAsBA,EAAWlH,OAAS,EAC1CgH,EAAQzC,KAAKQ,WAAWV,EAAUhF,IAElC4I,EAAUrH,GAAGuH,MAAM9D,EAAS5D,MAC5BuG,EAAQzC,KAAK8D,UAAUhE,GAAWiE,OAAQ,WAAYC,SAAS,IAC/DvB,EAAMlC,SAAS,SAGnB,MACJ,KAAK,QACD,GAAIoC,GAAa7C,EAAS1D,OACR,OAAduG,GAAsBA,EAAWlH,OAAS,EAC1CgH,EAAQzC,KAAKQ,WAAWV,EAAUhF,IAElC4I,EAAUrH,GAAGuH,MAAM9D,EAAS5D,MAC5BuG,EAAOzC,KAAK8D,UAAUhE,GAAWkE,SAAS,IAC1CvB,EAAMlC,SAAS,SAGnB,MACJ,KAAK,aACD,GAAIoC,GAAa7C,EAAS1D,OACR,OAAduG,GAAsBA,EAAWlH,OAAS,EAC1CgH,EAAQzC,KAAKQ,WAAWV,EAAUhF,IAElC4I,EAAUrH,GAAGuH,MAAM9D,EAAS5D,MAC5BuG,EAAOzC,KAAKiE,gBAAgBnE,GAC5B2C,EAAMlC,SAAS,cAGnB,MACJ,KAAK,SACD,GAAIoC,GAAa7C,EAAS1D,OACR,OAAduG,GAAsBA,EAAWlH,OAAS,EAC1CgH,EAAQzC,KAAKQ,WAAWV,EAAUhF,IAElC4I,EAAUrH,GAAGuH,MAAM9D,EAAS5D,MAC5BuG,EAAOzC,KAAKkE,YAAYpE,GACxB2C,EAAMlC,SAAS,UAGnB,MACJ,KAAK,eACD,GAAIoC,GAAa7C,EAAS1D,OACR,OAAduG,GAAsBA,EAAWlH,OAAS,EAC1CgH,EAAQzC,KAAKQ,WAAWV,EAAUhF,IAElC4I,EAAUrH,GAAGuH,MAAM9D,EAAS5D,MAC5BuG,EAAOzC,KAAKmE,kBAAkBrE,GAC9B2C,EAAMlC,SAAS,gBAGnB,MACJ,KAAK,QACD,GAAIoC,GAAa7C,EAAS1D,OACR,OAAduG,GAAsBA,EAAWlH,OAAS,EAC1CgH,EAAQzC,KAAKQ,WAAWV,EAAUhF,IAElC4I,EAAUrH,GAAGuH,MAAM9D,EAAS5D,MAC5BuG,EAAQzC,KAAKoE,WAAWtE,GAAWiE,OAAQ,YAC3CtB,EAAMlC,SAAS,SAGnB,MACJ,KAAK,UACD,GAAIoC,GAAa7C,EAAS1D,OACR,OAAduG,GAAsBA,EAAWlH,OAAS,EAC1CgH,EAAQzC,KAAKQ,WAAWV,EAAUhF,IAElC4I,EAAUrH,GAAGuH,MAAM9D,EAAS5D,MAC5BuG,EAAQzC,KAAKoE,WAAWtE,GAAWuE,UAAU,EAAMN,OAAQ,YAC3DtB,EAAMlC,SAAS,WAGnB,MACJ,KAAK,mBACD,GAAIoC,GAAa7C,EAAS1D,OACR,OAAduG,GAAsBA,EAAWlH,OAAS,EAC1CgH,EAAQzC,KAAKQ,WAAWV,EAAUhF,IAElC4I,EAAUrH,GAAGuH,MAAM9D,EAAS5D,MAC5BuG,EAAQzC,KAAKsE,WAAWxE,EAAU,oBAClC2C,EAAMlC,SAAS,oBAGnB,MACJ,KAAK,UACD,GAAIoC,GAAa7C,EAAS1D,OACR,OAAduG,GAAsBA,EAAWlH,OAAS,EAC1CgH,EAAQzC,KAAKQ,WAAWV,EAAUhF,IAElC4I,EAAUrH,GAAGuH,MAAM9D,EAAS5D,MAC5BuG,EAAQzC,KAAKsE,WAAWxE,EAAU,WAClC2C,EAAMlC,SAAS,WAGnB,MACJ,KAAK,SACD,GAAIoC,GAAa7C,EAAS1D,OACR,OAAduG,GAAsBA,EAAWlH,OAAS,EAC1CgH,EAAQzC,KAAKQ,WAAWV,EAAUhF,IAElC4I,EAAUrH,GAAGuH,MAAM9D,EAAS5D,MAC5BuG,EAAQzC,KAAKsE,WAAWxE,EAAU,UAClC2C,EAAMlC,SAAS,UAGnB,MACJ,KAAK,gBACD,GAAIoC,GAAa7C,EAAS1D,OACR,OAAduG,GAAsBA,EAAWlH,OAAS,EAC1CgH,EAAQzC,KAAKQ,WAAWV,EAAUhF,IAElC4I,EAAUrH,GAAGuH,MAAM9D,EAAS5D,MAC5BuG,EAAQzC,KAAKuE,UAAUzE,GACvB2C,EAAMlC,SAAS,iBAGnB,MACJ,KAAK,mBACD,GAAIoC,GAAa7C,EAAS1D,OACR,OAAduG,GAAsBA,EAAWlH,OAAS,EAC1CgH,EAAQzC,KAAKQ,WAAWV,EAAUhF,IAElC4I,EAAUrH,GAAGuH,MAAM9D,EAAS5D,MAC5BuG,EAAQzC,KAAKuE,UAAUzE,GACvB2C,EAAMlC,SAAS,oBAGnB,MACJ,KAAK,cACD,GAAIoC,GAAa7C,EAAS1D,OACR,OAAduG,GAAsBA,EAAWlH,OAAS,EAC1CgH,EAAQzC,KAAKQ,WAAWV,EAAUhF,IAElC4I,EAAUrH,GAAGuH,MAAM9D,EAAS5D,MAC5BuG,EAAQzC,KAAKwE,iBAAiB1E,GAC9B2C,EAAMlC,SAAS,eAGnB,MAEJ,KAAK,OACD,KACJ,SACIqC,EAAW9C,EAAS+C,KACpB,IAAIF,GAAa7C,EAAS1D,OAC1B,IAAkB,MAAduG,GAAsBA,EAAWlH,OAAS,EAC1CgH,EAAQzC,KAAKQ,WAAWV,EAAUhF,OAChC,CACF,GAAIgI,EAEAA,GADW,MAAXJ,EACYA,EAAU,IAAM9H,EAAQkB,OAAS,MAAQ8G,EAEzChI,EAAQkB,OAAS,KAAO8G,EAExCH,EAAQpG,GAAG0G,KAAKD,GAAYE,aAAa,IACrClC,GAAWvE,SAAY,EACvBkG,EAAM7C,IAAI,GAAIqD,mBAAoBpG,SAC3BiE,GAAWvE,SAAY,EAC9BkG,EAAM7C,IAAI,GAAIqD,mBAAoBrG,SAElC6F,EAAM7C,IAAI,GAAIqD,mBAAoBhG,SAEtCwF,EAAMlC,SAAS,WAI3B,OAAQkC,EAAOiB,IAUnBrJ,QAAQ6D,UAAUiF,eAAiB,SAAUV,EAAO3C,GAChD,GAAI2E,GAAY3E,EAAS4E,MACrBC,EAAW7E,EAASiB,KAGxB,IAAiB,MAAb0D,EACA,IAAK,GAAItJ,GAAI,EAAGA,EAAIsJ,EAAUhJ,OAAQN,IAE9BsJ,EAAUtJ,IAAMoB,SAAY,EAC5BkG,EAAM7C,IAAIzE,GAAI8H,mBAAoBpG,SAC3B4H,EAAUtJ,IAAMoB,SAAY,EACnCkG,EAAM7C,IAAIzE,GAAI8H,mBAAoBrG,SAElC6F,EAAM7C,IAAIzE,GAAI8H,mBAAqBhG,QAK/C,IAAgB,MAAZ0H,GAAuC,GAAnBA,EAASlJ,OAAY,CACzC,GAAIsF,GAAQI,SAASwD,EAAS,GAC9BlC,GAAM7C,IAAImB,GAAQkC,mBAAoBtG,eAI9CtC,QAAQ6D,UAAU4F,UAAU,SAAShE,EAAU8E,GAC3C,GAAIC,GAAY/E,EAAS+C,MACrB8B,EAAW7E,EAASiB,MACpB0D,EAAY3E,EAAS4E,MAErBjC,EAAQpG,GAAGyI,GAAG9C,MAAM6C,EAAWD,EAGnC,IAAiB,MAAbH,EACA,IAAK,GAAItJ,GAAI,EAAGA,EAAIsJ,EAAUhJ,OAAQN,IAE9BsJ,EAAUtJ,IAAMoB,SAAY,EAC5BkG,EAAM7C,IAAIzE,GAAI8H,mBAAoBpG,SAC3B4H,EAAUtJ,IAAMoB,SAAY,GACnCkG,EAAM7C,IAAIzE,GAAI8H,mBAAoBrG,QAK9C,IAAgB,MAAZ+H,GAAuC,GAAnBA,EAASlJ,OAAY,CACzC,GAAIsF,GAAQI,SAASwD,EAAS,GAC9BlC,GAAM7C,IAAImB,GAAQkC,mBAAoBtG,aAI1C,MADA8F,GAAMsC,WAAWtC,EAAMP,WAAW8C,WAAWvC,EAAML,aAC5CK,GAIXpI,QAAQ6D,UAAUmF,iBAAmB,SAASZ,EAAO3C,KAIrDzF,QAAQ6D,UAAUgG,YAAc,SAASpE,GAErC,GACImF,IADanF,EAAS5D,KACX4D,EAAS+C,OAEpBJ,EAAQpG,GAAGyI,GAAGI,OAAOD,GAAYE,MAAO,UAE5C,OADA1C,GAAMsB,SACCtB,GAGXpI,QAAQ6D,UAAUoF,uBAAyB,SAAUb,EAAO3C,GASxD,IAAK,GARDsF,GAAWtF,EAAS4E,MACpBW,EAAYvF,EAASuF,UACrBC,EAAaxF,EAASwF,WAGtBC,GAFWzF,EAASiB,MAEa,GAApBsE,EAAU5J,QAAoC,GAArB6J,EAAW7J,QAG5CN,EAAE,EAAGA,EAAEiK,EAAS3J,OAAQN,IAC7B,IAAK,GAAI0E,GAAE,EAAGA,EAAEuF,EAASjK,GAAGM,OAAQoE,IAC5BuF,EAASjK,GAAG0E,IAAMtD,SAAY,EAC3BgJ,EACC9C,EAAM7C,IAAIzE,EAAE,EAAE0E,EAAE,GAAGoD,mBAAoBpG,SAEvC4F,EAAM7C,IAAIzE,EAAE0E,GAAGoD,mBAAoBpG,SAGlCuI,EAASjK,GAAG0E,IAAMtD,SAAY,EAChCgJ,EACC9C,EAAM7C,IAAIzE,EAAE,EAAE0E,EAAE,GAAGoD,mBAAoBrG,SAEvC6F,EAAM7C,IAAIzE,EAAE0E,GAAGoD,mBAAoBrG,SAGpC2I,EACC9C,EAAM7C,IAAIzE,EAAE,EAAE0E,EAAE,GAAGoD,mBAAqBhG,SAExCwF,EAAM7C,IAAIzE,EAAE0E,GAAGoD,mBAAqBhG,UAOxD5C,QAAQ6D,UAAUiG,kBAAkB,SAASrE,GACzC,GAAImF,GAAYnF,EAAS+C,MACrBuC,EAAWtF,EAAS4E,MACpBc,EAAW1F,EAAS2F,MACpBC,EAAehL,EAAEiL,QAAO,KAAU7F,EAASuF,WAC3CO,EAAgBlL,EAAEiL,QAAO,KAAU7F,EAASwF,YAI5CD,GAHWvF,EAASiB,MAGRrG,EAAEmL,IAAIH,EAAc,SAAS7C,EAAO9B,GAChD,OAAQ8B,MAIRyC,EAAa5K,EAAEmL,IAAID,EAAe,SAAS/C,EAAO9B,GAClD,OAAQ8B,KAKR0C,EAAiC,GAApBF,EAAU5J,QAAoC,GAArB6J,EAAW7J,OAGjDqK,EAAepL,EAAEiL,QAAO,KAAUV,GAClCc,EAAerL,EAAEmL,IAAIC,EAAc,SAASjD,EAAO9B,GACnD,OAAQ8B,IAGZ,IAAI0C,EAAU,CAgBV,IAAK,GAAIpK,GAAEkK,EAAU5J,OAAQN,EAAE4K,EAAa,GAAGtK,OAAQN,IACnDkK,EAAUlG,OAAO,EAAE,EAAG,GAE1B,KAAK,GAAIhE,GAAEmK,EAAW7J,OAAQN,EAAE4K,EAAatK,OAAQN,IACjDmK,EAAWnG,OAAO,EAAE,EAAG,GAE3B4G,GAAa5G,OAAO,EAAE,EAAEkG,GAExBU,EAAa,GAAG5G,OAAO,EAAG,EAAG,GAE7B,KAAK,GAAIhE,GAAE,EAAGA,EAAE4K,EAAatK,OAAQN,IACjC4K,EAAa5K,GAAGgE,OAAO,EAAE,EAAEmG,EAAWnK,EAAE,IAKhD,GAAIsH,GAAQpG,GAAGyI,GAAGI,OAAOa,GAAeZ,MAAO,SAG/C,IAAII,EAAU,CACV,IAAK,GAAIpK,GAAE,EAAGA,EAAE4K,EAAa,GAAGtK,OAAQN,IACpCsH,EAAM7C,IAAI,EAAGzE,GAAI8H,mBAAoBjG,mBAEzC,KAAK,GAAI7B,GAAE,EAAGA,EAAE4K,EAAatK,OAAQN,IACjCsH,EAAM7C,IAAIzE,EAAG,GAAI8H,mBAAoBjG,oBAK7C,IAAK,GAAI7B,GAAE,EAAGA,EAAEiK,EAAS3J,OAAQN,IAC7B,IAAK,GAAI0E,GAAE,EAAGA,EAAEuF,EAASjK,GAAGM,OAAQoE,IAC5BuF,EAASjK,GAAG0E,IAAMtD,SAAY,EAC3BgJ,EACC9C,EAAM7C,IAAIzE,EAAE,EAAE0E,EAAE,GAAGoD,mBAAoBpG,SAEvC4F,EAAM7C,IAAIzE,EAAE0E,GAAGoD,mBAAoBpG,SAGlCuI,EAASjK,GAAG0E,IAAMtD,SAAY,IAChCgJ,EACC9C,EAAM7C,IAAIzE,EAAE,EAAE0E,EAAE,GAAGoD,mBAAoBrG,SAEvC6F,EAAM7C,IAAIzE,EAAE0E,GAAGoD,mBAAoBrG,SAMnD,KAAK,GAAIzB,GAAE,EAAGA,EAAEqK,EAAS/J,OAAQN,IAAI,CAEjC,GAAI6K,GAAI7E,SAASqE,EAASrK,GAAG,IACzB8K,EAAI9E,SAASqE,EAASrK,GAAG,IACzBuB,EAAIyE,SAASqE,EAASrK,GAAG,IACzB+K,EAAI/E,SAASqE,EAASrK,GAAG,IACzBiG,IACC4E,GAAEZ,EAAS3J,QAAUwK,EAAEb,EAASY,GAAGvK,QAAUiB,EAAE0I,EAAS3J,QAAUyK,EAAEd,EAAS1I,GAAGjB,SAC5E2J,EAASY,GAAGC,IAAM1J,SAAY,GAAK6I,EAAS1I,GAAGwJ,IAAM3J,SAAY,KACtE6E,EAAO1G,EAAEiL,QAAQQ,OAAUpJ,aAE3BwI,IACAS,IAAKC,IAAKvJ,IAAKwJ,KAGnBzD,EAAM2D,QAAQJ,EAAEC,EAAEvJ,EAAEwJ,EAAE9E,GAI1B,MADAqB,GAAMsB,SACCtB,GAGXpI,QAAQ6D,UAAUgF,eAAe,SAAST,EAAO3C,GAE7C,GAEIuG,GAFAC,EAAYxG,EAAS4E,MACrBC,EAAW7E,EAASiB,KAER,OAAZ4D,GAAuC,GAAnBA,EAASlJ,SAC7B4K,EAAW1B,EAAS,GAGxB,IAAI4B,GAAQ,CACZ,KAAI,GAAI3H,KAAO0H,GAEPA,EAAU1H,IAAQrC,SAAY,GAC9BkG,EAAM7C,IAAI,EAAG2G,GAAQtD,mBAAoBpG,SACzC4F,EAAM7C,IAAI,EAAG2G,GAAQtD,mBAAoBpG,UACnCyJ,EAAU1H,IAAQrC,SAAY,GACpCkG,EAAM7C,IAAI,EAAG2G,GAAQtD,mBAAoBrG,SACzC6F,EAAM7C,IAAI,EAAG2G,GAAQtD,mBAAoBrG,WAEzC6F,EAAM7C,IAAI,EAAG2G,GAAQtD,mBAAqBhG,SAC1CwF,EAAM7C,IAAI,EAAG2G,GAAQtD,mBAAqBhG,UAE1C2B,GAAOyH,IACP5D,EAAM7C,IAAI,EAAG2G,GAAQtD,mBAAoBtG,aACzC8F,EAAM7C,IAAI,EAAG2G,GAAQtD,mBAAoBtG,cAE7C4J,KAKRlM,QAAQ6D,UAAU2F,UAAU,SAAS/D,GACjC,GAAI0G,GAAQ1G,EAAS+C,MAAOyD,EAAUxG,EAAS4E,MAC3CC,EAAW7E,EAASiB,MAEpBA,EAAQ,GAKRmE,GAHQsB,EAAQ/K,OAGP,GAAIgL,QACbC,EAAW,GAAID,OAAM,OACrBE,EAAY,GAAIF,OAAM,OACtBF,EAAQ,CACZ,KAAI,GAAI3H,KAAO4H,GACXE,EAAS9K,KAAKgD,GACd+H,EAAU/K,KAAK4K,EAAQ5H,IAEP,MAAZ+F,GAAuC,GAAnBA,EAASlJ,QAAekJ,EAAS,IAAM/F,IAC3DmC,EAAQwF,GAEZA,GAGJrB,GAAOtJ,KAAK8K,GACZxB,EAAOtJ,KAAK+K,EAEZ,IAAIlE,GAAQpG,GAAGyI,GAAGI,OAAOA,EAGzBqB,GAAQ,CACR,KAAI,GAAI3H,KAAO0H,GAEPA,EAAU1H,IAAQrC,SAAY,GAC9BkG,EAAM7C,IAAI,EAAG2G,GAAQtD,mBAAoBpG,SACzC4F,EAAM7C,IAAI,EAAG2G,GAAQtD,mBAAoBpG,UACnCyJ,EAAU1H,IAAQrC,SAAY,IACpCkG,EAAM7C,IAAI,EAAG2G,GAAQtD,mBAAoBrG,SACzC6F,EAAM7C,IAAI,EAAG2G,GAAQtD,mBAAoBrG,UAE7C2J,GASJ,OALa,IAATxF,IACA0B,EAAM7C,IAAI,EAAGmB,GAAQkC,mBAAoBtG,aACzC8F,EAAM7C,IAAI,EAAGmB,GAAQkC,mBAAoBtG,cAGtC8F,GAGXpI,QAAQ6D,UAAUkF,qBAAsB,SAAUX,EAAO3C,GAIrD,IAAK,GAHD2E,GAAY3E,EAAS4E,MACrBC,EAAW7E,EAASiB,MAEf5F,EAAE,EAAGA,EAAEsJ,EAAUhJ,OAAQN,IAC1BsJ,EAAUtJ,IAAMoB,SAAY,EAC5BkG,EAAMF,IAAIpH,GAAGyE,KAAKqD,mBAAoBpG,SACjC4H,EAAUtJ,IAAMoB,SAAY,EACjCkG,EAAMF,IAAIpH,GAAGyE,KAAKqD,mBAAoBrG,SAEtC6F,EAAMF,IAAIpH,GAAGyE,KAAKqD,mBAAqBhG,QAI/C,IAAgB,MAAZ0H,GAAuC,GAAnBA,EAASlJ,OAAa,CAC1C,GAAIsF,GAAQI,SAASwD,EAAS,GAC9BlC,GAAMF,IAAIxB,GAAOnB,KAAKqD,mBAAoBtG,eAIlDtC,QAAQ6D,UAAU+F,gBAAgB,SAASnE,GAQvC,IAAK,GAPD2E,GAAY3E,EAAS4E,MACrBC,EAAW7E,EAASiB,MACpB6F,EAAU9G,EAAS+C,MAGnBJ,GAFU3C,EAAS5D,KAEXG,GAAGyI,GAAG+B,QAET1L,EAAE,EAAGA,EAAEyL,EAAQnL,OAAQN,IAE5BsH,EAAMqE,QAAQF,EAAQzL,IAClBsJ,EAAUtJ,IAAMoB,SAAY,EAC5BkG,EAAMF,IAAIpH,GAAGyE,KAAKqD,mBAAoBpG,SACjC4H,EAAUtJ,IAAMoB,SAAY,GACjCkG,EAAMF,IAAIpH,GAAGyE,KAAKqD,mBAAoBrG,QAI9C,IAAgB,MAAZ+H,GAAuC,GAAnBA,EAASlJ,OAAa,CAC1C,GAAIsF,GAAQI,SAASwD,EAAS,GAC9BlC,GAAMF,IAAIxB,GAAOnB,KAAKqD,mBAAoBtG,aAI9C,MADA8F,GAAMsB,SACCtB,GAGXpI,QAAQ6D,UAAUkG,WAAW,SAAStE,EAAU8E,GAQ5C,IAAI,GAPAmC,GAAajH,EAASkH,EACtBC,EAAWnH,EAASoH,EAEpBC,EAAQ9K,GAAGyI,GAAGqC,MAAMvC,GAGpBwC,KACIjM,EAAE,EAAGA,EAAE4L,EAAWtL,OAAQN,IAAI,CAClC,GAAIkM,GAASN,EAAW5L,GAAG0H,MACvByE,EAAQP,EAAW5L,GAAGmM,MAAMC,cAC5BC,EAAOL,EAAMM,QAAQJ,EACzBG,GAAK5H,KAAKqD,mBAAoB/F,WAAWoK,KACzCF,EAAWC,GAAUG,EAIzB,IAAK,GAAIrM,GAAE,EAAGA,EAAE8L,EAASxL,OAAQN,IAAI,CACjC,GAAIuM,GAAQT,EAAS9L,GAAGuM,MACpBC,EAAMV,EAAS9L,GAAGwM,IAClBL,EAAQL,EAAS9L,GAAGmM,MACpBM,EAASX,EAAS9L,GAAGyM,MACzBT,GAAMf,QAAQgB,EAAWM,GAAQN,EAAWO,IAAOC,OAAUA,EAAQzB,OAAUmB,IAInF,MADAH,GAAMpD,SACCoD,GAGX9M,QAAQ6D,UAAUqF,gBAAkB,SAAUd,EAAO3C,GAIjD,GAAI+H,GAAOpF,EAAMoF,MACjB7H,MAAK8H,oBAAoBD,IAG7BxN,QAAQ6D,UAAU4J,oBAAsB,SAASN,GAC7CA,EAAK5H,KAAKqD,mBAAqBhG,SAC3BuK,EAAKO,QACL/H,KAAK8H,oBAAoBN,EAAKO,QAE9BP,EAAKQ,SACLhI,KAAK8H,oBAAoBN,EAAKQ,UAItC3N,QAAQ6D,UAAUoG,WAAW,SAASxE,EAAUmI,GAC5C,GAKIC,GALAC,EAAO9L,GAAGyI,GAAGsD,aAEbC,GADWvI,EAASiB,MACTjB,EAAS4E,OACpB9B,EAAW9C,EAAS+C,MACpByF,EAAUxI,EAASwH,KAEP,WAAZW,IACAC,EAAQI,EAAQtM,QAAQ,MAAM,KAAKA,QAAQ,MAAM,KAAKf,MAAM,QAWhE,KAAK,GAJDuM,GAEAe,EANAnD,EAAWiD,EAASrM,QAAQ,MAAM,KAAKA,QAAQ,MAAM,KAAKf,MAAM,QAChES,KACA8M,KACA7M,EAAQ,GAERL,EAAMsH,EAEN6F,EAAY,EACPtN,EAAE,EAAGA,EAAEG,EAAIG,OAAON,IACvB,OAAOG,EAAIH,IAEP,IAAK,IACDO,EAASE,KAAKN,EAAIH,GAElB,MACJ,KAAK,IAGD,GADAO,EAASG,MACY,GAAjBH,EAASD,OACT+L,EAAKgB,EAAU3M,MACfsM,EAAKN,KAAKL,OAET,CAED,GADAA,EAAKgB,EAAU3M,MACH,MAAR2L,EACA,QAGJe,GAASC,EAAU/M,OAAO,EAEtB0F,SAASqG,EAAK3E,SAAS1B,SAASqH,EAAUD,GAAU1F,SACpD2F,EAAUD,GAAUR,KAAKP,GAEzBgB,EAAUD,GAAUP,MAAMR,GAGlC,KACJ,SACI,KAAc,KAARlM,EAAIH,IAAmB,KAARG,EAAIH,IAAWA,EAAEG,EAAIG,QACvCE,GAAYL,EAAIH,GAChBA,GAAI,CAEPQ,GAAQA,EAAMG,OAAOE,QAAQ,MAAO,IAAIA,QAAQ,MAAO,IAC5C,QAAPL,GACA6L,EAAOW,EAAKO,QAAQ/M,GAChByJ,EAASqD,IAAa,IACtBjB,EAAK5H,KAAK+I,eAAgB7L,OAAQ8L,eAAgB,QAClDxD,EAASqD,IAAc,GAEX,UAAZR,EACwB,KAApBC,EAAMO,GACNjB,EAAK5H,KAAKqD,mBAAoB/F,WAAgB,MACrB,KAApBgL,EAAMO,IACXjB,EAAK5H,KAAK0H,MAAQ,QAAQrE,mBAAoB,UAG9CmC,EAASqD,IAAclM,SAAY,EACnCiL,EAAK5H,KAAKqD,mBAAoBrG,SACzBwI,EAASqD,IAAclM,SAAY,GACxCiL,EAAK5H,KAAKqD,mBAAoBpG,SAKtC2L,EAAU5M,KAAK4L,IAGfgB,EAAU5M,KAAK,MAEnB6M,IACA9M,EAAM,GACNR,GAAI,EAKhB,MADAgN,GAAKpE,SACEoE,GAGX9N,QAAQ6D,UAAUsF,eAAe,SAASf,EAAO3C,KAMjDzF,QAAQ6D,UAAUqG,UAAU,SAASzE,GAQjC,IAAK,GAPDqI,GAAO9L,GAAGyI,GAAGsD,aAEbhD,GADWtF,EAASiB,MACTjB,EAAS4E,OACpBmE,EAAS/I,EAAS+C,MAClBiG,KAGK3N,EAAE,EAAGA,EAAE0N,EAAOpN,OAAQN,IAAI,CAC/B,GAAIuN,GAAUP,EAAKO,QAAQG,EAAO1N,GAOlC,IANKiK,EAASjK,IAAMoB,SAAY,EAC5BmM,EAAQ9I,KAAKqD,mBAAoBrG,SAC5BwI,EAASjK,IAAMoB,SAAY,GAChCmM,EAAQ9I,KAAKqD,mBAAoBpG,SAErCiM,EAASlN,KAAK8M,GACL,GAALvN,EACAgN,EAAKN,KAAKa,OACT,CACD,GAAIK,GAAc5H,UAAUhG,EAAE,GAAG,EAC7BA,GAAE,GAAK,EACP2N,EAASC,GAAaf,MAAMU,GAE5BI,EAASC,GAAahB,KAAKW,IAMvC,MADAP,GAAKpE,SACEoE,GAGX9N,QAAQ6D,UAAUuF,qBAAuB,SAAUhB,EAAOuG,KAI1D3O,QAAQ6D,UAAUsG,iBAAiB,SAAS1E,GAExC,GAAIqI,GAAO9L,GAAGyI,GAAGqD,OAEb3B,GADW1G,EAASiB,MACVjB,EAAS+C,OACnBoG,EAAWnJ,EAAS4E,MACpBwE,KAGArB,EAAOM,EAAKN,MAChBA,GAAKtJ,MAAM4K,WAAa,GAExB,KAAK,GAAIvK,KAAO4H,GAAQ,CACpB,GAAI3D,GAAQ2D,EAAQ5H,EACpB,MAAMA,IAAOsK,IAAU,CACnB,GAAIR,GAAUP,EAAKO,QAAQ9J,EACvBqK,GAASrK,IAAQrC,SAAY,EAC7BmM,EAAQ9I,KAAKqD,mBAAoBrG,SAC5BqM,EAASrK,IAAQrC,SAAY,GAClCmM,EAAQ9I,KAAKqD,mBAAoBpG,SAErCqM,EAAStK,GAAO8J,EAEpB,KAAM7F,IAASqG,IAAU,CACrB,GAAIR,GAAUP,EAAKO,QAAQ7F,EACvBoG,GAASpG,IAAUtG,SAAY,EAC/BmM,EAAQ9I,KAAKqD,mBAAoBrG,SAC5BqM,EAASpG,IAAUtG,SAAY,GACpCmM,EAAQ9I,KAAKqD,mBAAoBpG,SAErCqM,EAASrG,GAAS6F,EAGlB9J,GAAOiE,GACPgF,EAAKuB,SAASF,EAAStK,IAEvBsK,EAAStK,GAAKyK,eAAe9K,QAE7B2K,EAASrG,GAAOuG,SAASF,EAAStK,IAK1C,MADAuJ,GAAKpE,SACEoE","file":"vizJSAV.min.js","sourcesContent":["//replace ' by \" and JSON.parse()\r\n//Never change the variable object itself!!!, Use deepcopy everytime the program needs to change the content\r\n\r\nvar jsonContent = {}, currentStat;//statement_XXX\r\nvar glbFlags = {\"u\" :0, \"n\": 1, \"c\": 2};\r\n\r\n//using highlight will not be overwritten by later css, so we do not use highlight\r\nvar indexColor = \"rgb(255, 163, 163)\",\r\n    nColor = \"rgb(217, 255, 178)\",\r\n    cColor = \"rgb(255, 255, 162)\",\r\n    bColor = \"red\",\r\n    edgeColor = \"rgb(255, 102, 255)\",\r\n    matrixHeaderColor = \"rgb(152,152,152)\",\r\n    uColor = \"white\";\r\n\r\nvar graphColor = {\r\n    \"RED\": \"rgb(217, 137, 137)\",\r\n    \"BLUE\": \"rgb(138, 138, 230)\",\r\n    \"GRAY\": \"rgb(204, 204, 204)\",\r\n    \"WHITE\": \"rgb(255, 255, 255)\",\r\n    \"YELLOW\": \"rgb(255, 255, 153)\",\r\n    \"GREEN\": \"rgb(162, 243, 162)\",\r\n    \"BLACK\": \"rgb(0, 0, 0)\"\r\n};\r\n\r\nvar DATATYPES = [\"Idict\", \"Ilist\", \"Stack\", \"Queue\", \"LinkedList\", \"Matrix\", \"StringMatrix\", \"set\", \"tuple\", \"Graph\",\r\n        \"DiGraph\", \"BinarySearchTree\", \"AVLTree\", \"RBTree\", \"BinaryMinHeap\", \"MinPriorityQueue\", \"DisjointSet\",\r\n        \"int\", \"str\", \"bool\", \"float\", \"NoneType\"],\r\n    OBJTYPES = [\"Idict\", \"Ilist\", \"Stack\", \"Queue\", \"LinkedList\", \"Matrix\", \"StringMatrix\", \"set\", \"tuple\", \"Graph\",\r\n        \"DiGraph\", \"BinarySearchTree\", \"AVLTree\", \"RBTree\", \"BinaryMinHeap\", \"MinPriorityQueue\", \"DisjointSet\"];\r\n\r\nvar av;\r\nvar jsavObjDict = {}; // key: depth, value: dict (key: name, value: jsav object)\r\nvar current_content, current_line;\r\nvar glbpointerList = [];//we need to update the pointer's position everytime, since hide() will cause mismatch between pointer and objects\r\nvar glbpointerParamList = [];//store all the necessary parameter to construct the pointer\r\nvar avDepthDict = {}; //depth_1 : av1 ....\r\nvar divDepthList = [];//div element of each layer\r\nvar container; //container is the most outer div that contains all the layers\r\n\r\n/***************************************For Local Browser testing purpose**************************/\r\n// var jsonPath= 'output.json';\r\n\r\n// $(document).ready(\r\n\r\n//     function(){\r\n//         $.getJSON(jsonPath, function(data){\r\n//             jsonContent = data;\r\n\r\n//         });\r\n//     }\r\n//  );\r\n\r\nfunction vizJSAV(divID,data){\r\n   jsonContent = data;\r\n   container = $(\"#\"+divID);\r\n}\r\n/***************************************End of testing********************************************/\r\n\r\n\r\n// function vizJSAV(divID, jsonObj){\r\n//     jsonContent = jsonObj;\r\n//     container = $(\"#\"+divID);\r\n// //    av = new JSAV(document.getElementById(divID));\r\n// }\r\n\r\n\r\n\r\nvizJSAV.prototype.animate = function(statementNo){\r\n    var statementLabel =\"statement_\"+statementNo;\r\n    currentStat = statementLabel;\r\n    if (!(statementLabel in jsonContent)){\r\n        return;// out of statement range\r\n    }\r\n\r\n    var depthList = jsonContent[statementLabel][\"vars\"];\r\n    current_content = jsonContent[statementLabel][\"current_content\"];\r\n    current_line = jsonContent[statementLabel][\"current_line\"];\r\n\r\n    glbpointerParamList = []; //empty the list\r\n    //hide and clear the pointer list\r\n    for (var i=0; i<glbpointerList.length; i++){\r\n        glbpointerList[i].hide();\r\n    }\r\n    glbpointerList = [];\r\n\r\n    var nameDict = {};\r\n\r\n    //Load all the variable name for this statement\r\n    for (var depth in depthList){\r\n        var varList = [];\r\n\r\n        var variableList = depthList[depth];\r\n        for (var i=0; i<variableList.length; i++){\r\n            var varName = variableList[i].name,\r\n                varType = variableList[i].type;\r\n                varList.push(varName);\r\n        }\r\n        nameDict[depth] = varList;\r\n    }\r\n\r\n    //pre-checking, clear the jsavobj that no longer exist in JSON\r\n    for (var depth in jsavObjDict){\r\n        for (var key in jsavObjDict[depth]){\r\n            if (!(depth in nameDict)){ //depth no longer exist in current statement, just remove the element inside is fine, no need to delete the key itself\r\n                for (var i=0; i<jsavObjDict[depth][key].length; i++){\r\n                    if (jsavObjDict[depth][key][i] != null){\r\n                        jsavObjDict[depth][key][i].hide();\r\n                    }\r\n                }\r\n                delete jsavObjDict[depth][key];\r\n            }else{ //current statement has the corresponding depth\r\n                if (nameDict[depth].indexOf(key) == -1){ // this variable no longer exist in this depth\r\n                    for (var i=0; i<jsavObjDict[depth][key].length; i++){\r\n                        if (jsavObjDict[depth][key][i] != null){\r\n                            jsavObjDict[depth][key][i].hide();\r\n                        }\r\n                    }\r\n                    delete jsavObjDict[depth][key];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //create or hide layer\r\n    var preLayerCount = divDepthList.length,\r\n       curLayerCount = Object.keys(depthList).length;\r\n\r\n    //remove layer\r\n    if (preLayerCount > curLayerCount){\r\n        for (var i = curLayerCount; i < preLayerCount; i++) {\r\n            delete avDepthDict[\"depth_\"+(i+1)];\r\n            divDepthList[i].remove();//hide the div element\r\n        }\r\n        //remove the element\r\n        divDepthList.splice(curLayerCount, preLayerCount-curLayerCount);\r\n    }\r\n    //add layer\r\n    if (preLayerCount < curLayerCount) {\r\n        for (var i = preLayerCount; i < curLayerCount; i++) {\r\n            var layer = $(\"<div id='layer\"+(i+1)+\"' class='graphlayer'><span>layer for function call depth: \"+(i+1)+\"</span></div>\");\r\n            container.append(layer);\r\n            var avObj = new JSAV(layer);\r\n\r\n            avDepthDict[\"depth_\" + (i + 1)] = avObj;\r\n            divDepthList[i] = layer;\r\n\r\n        }\r\n    }\r\n\r\n    //reset the width of layer div\r\n    var containerWidth = container.width()\r\n        padding = 10, //padding-left:30, padding-right: 30, otherwise pointer may be out of border\r\n        singleLayerWidth = (containerWidth-(2*padding*curLayerCount))/curLayerCount;\r\n    $(\".graphlayer\").css(\"width\", singleLayerWidth);\r\n    $(\".graphlayer\").css(\"padding-left\", padding);\r\n    $(\".graphlayer\").css(\"padding-right\", padding);\r\n\r\n    //start plotting the new variables\r\n    for (var depth in depthList){\r\n        //if jsavObjDict does not have this depth, add it\r\n        if (!(depth in jsavObjDict)){\r\n            jsavObjDict[depth] = {};\r\n        }\r\n\r\n        var variableList = depthList[depth];\r\n        for (var j=0; j<variableList.length; j++){\r\n             var variable = variableList[j];\r\n             if (variable != null){\r\n                 var varName = variable.name;\r\n                 /*\r\n                    Condition 1:\r\n                    for i ....\r\n                        for j....\r\n                            i ....\r\n                            here i varFlag is 0, we need to add !(varName in jsavObjDict[depth]) to make sure variables are printed\r\n                    Condition 2:\r\n                        Refresh the color: for example b = [1,2] b[0] =1, b varFlag is 0, but index may changed.\r\n                    Condition 3:\r\n                        for new statement, we need to clear the color\r\n\r\n                    Solution:\r\n                    1. if variable not in dict, plot it even varFlag is 0.\r\n                    2. if varFlag is 0, refresh the index and flags\r\n                    3. For pointer, refresh the object it points to and refresh the pointer everytime since the jsavobj may be removed.\r\n\r\n                  */\r\n                 var varPointer = variable.pointer;\r\n                 av = avDepthDict[depth];\r\n\r\n                 //if ((varPointer != null && varPointer.length != 0) || variable.varFlag != glbFlags[\"u\"] || !(varName in jsavObjDict[depth])){ //u means not changed, we do not need to draw it again\r\n                    var jsavObjList = this.plotVar(variable, depth);\r\n                    jsavObjDict[depth][varName] = jsavObjList;\r\n                 //}else{\r\n                 //   this.refreshFlag(variable, depth);\r\n                 //}\r\n             }\r\n         }\r\n    }\r\n\r\n    //[variable.name, pointerObj, opts, className, depth_belongs to(depth_xxx), targetName], add pointer in the last, avoid updating pointer position when target is moved\r\n    for (var i=0; i<glbpointerParamList.length; i++){\r\n        //refresh the pointer position\r\n        if (glbpointerParamList[i][3] == \"myObjPointer\"){ //object pointer, we do not add svg path, just change the label\r\n            //glbpointerParamList.push([variable.name, labelObj, opts, className, \"depth_\"+depthNo, pointerName]);\r\n            //opts = {\"depth\": depth, \"index\": pointerIndex};\r\n            var pointerIndex = glbpointerParamList[i][2][\"index\"],\r\n                pointerDepth = glbpointerParamList[i][2][\"depth\"];\r\n            var message = glbpointerParamList[i][1].text();\r\n            message += \" <- \" + pointerDepth + \":\" + glbpointerParamList[i][0];\r\n            if (pointerIndex != null && pointerIndex.length !=0){\r\n                message += \", index: \"+ pointerIndex\r\n            }\r\n\r\n            glbpointerParamList[i][1].text(message);\r\n        }else{\r\n            var tempPointer = avDepthDict[glbpointerParamList[i][4]].pointer(glbpointerParamList[i][0], glbpointerParamList[i][1], glbpointerParamList[i][2]);\r\n            tempPointer.addClass(glbpointerParamList[i][3]);\r\n            glbpointerList.push(tempPointer);\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n/***************************************Plot one variable********************************************/\r\n\r\n//find the matching object inside jsavObjDict, return the depth that varName is in\r\n//return the depthNo instead of object for the div split usage\r\n// varName -> pointerName\r\nfunction findObj(varName, pointerName, depth){\r\n    /*\r\n        !!!important!!!\r\n        Find the first matching pointerName which is not a pointer\r\n     */\r\n    //get depth number\r\n    var depthNo = depth.match(/\\d+/)[0];\r\n    var depthStr;\r\n    if (isNaN(depthNo)){\r\n        return -1;\r\n    }\r\n\r\n    //since pointerobj in jsavObjDict is null, we can judge whether it is a pointer based on this\r\n    for (var i=depthNo; i >0; i--){\r\n        depthStr = \"depth_\" + i;\r\n        if (pointerName in jsavObjDict[depthStr] &&\r\n            ((pointerName == varName && i != depthNo) || (pointerName != varName))){\r\n            if (jsavObjDict[depthStr][pointerName][0] == null){\r\n                continue;\r\n            }\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n/*\r\n    @param pointerList: [pointerName, index], second element could be null\r\n    @param depth\r\n */\r\nvizJSAV.prototype.addPointer = function(variable, depth) {\r\n    var pointerList = variable.pointer,\r\n        varName = variable.name;\r\n    var pointerName = pointerList[0],\r\n        pointerIndex = pointerList[1]; //list\r\n\r\n    var depthNo = findObj(varName, pointerName, depth);\r\n\r\n    if (depthNo != -1) {\r\n        if (jsavObjDict[\"depth_\"+depthNo][pointerName].length == 0){\r\n            return null;\r\n        }\r\n        var pointerObj = jsavObjDict[\"depth_\"+depthNo][pointerName][0],\r\n            labelObj = jsavObjDict[\"depth_\"+depthNo][pointerName][1];\r\n\r\n        //get target variable\r\n        var variableList = jsonContent[currentStat][\"vars\"][\"depth_\" + depthNo];\r\n        var pointerVar;\r\n        for (var j = 0; j < variableList.length; j++) {\r\n            var pointerVariable = variableList[j];\r\n            if (pointerVariable.name == pointerName) {\r\n                pointerVar = pointerVariable;\r\n            }\r\n        }\r\n\r\n        if (variable.varFlag != glbFlags[\"u\"]){\r\n            if (pointerObj != null) {\r\n                pointerObj.hide();\r\n            }\r\n            if (labelObj != null) {\r\n                labelObj.hide();\r\n            }\r\n\r\n            //only update if variable's index exist, avoiding overwriting target's index during refreshing\r\n            if (pointerIndex != null && pointerIndex.length != 0){\r\n                pointerVar.index = pointerIndex;\r\n            }\r\n            if (variable.index != null && variable.index.length != 0) { //this has a higher priority than the up one\r\n                pointerVar.index = variable.index;// since pointer's index may not be updated\r\n            }\r\n\r\n            var currentAv = av;\r\n            av = avDepthDict[\"depth_\"+depthNo];\r\n\r\n            jsavObjDict[\"depth_\" + depthNo][pointerName] = this.plotVar(pointerVar, \"depth_\" + depthNo);\r\n\r\n            av = currentAv;\r\n\r\n            pointerObj = jsavObjDict[\"depth_\" + depthNo][pointerName][0];\r\n            labelObj = jsavObjDict[\"depth_\" + depthNo][pointerName][1];\r\n\r\n            //update current glbpointerParamList, because the pointerVar is changed, if two pointer point to the same obj, previous one's target is not wrong\r\n            for (var i=0; i<glbpointerParamList.length; i++){\r\n                if (glbpointerParamList[i][4] == \"depth_\"+depthNo && glbpointerParamList[i][5] == pointerName){\r\n                    if (glbpointerParamList[i][3] == \"myObjPointer\") {\r\n                        glbpointerParamList[i][1] = labelObj;\r\n                    }else{\r\n                        glbpointerParamList[i][1] = pointerObj;\r\n                        glbpointerParamList[i][2][\"anchor\"] = \"right top\";//avoid overlapping\r\n                    }\r\n                }\r\n            }\r\n\r\n        }else{\r\n            //only update if variable's index exist, avoiding overwriting target's index during refreshing\r\n            if (pointerIndex != null && pointerIndex.length != 0){\r\n                pointerVar.index = pointerIndex;\r\n            }\r\n            if (variable.index != null && variable.index.length != 0) { //this has a higher priority than the up one\r\n                pointerVar.index = variable.index;// since pointer's index may not be updated\r\n            }\r\n            this.refreshFlag(pointerVar, \"depth_\" + depthNo);\r\n        }\r\n\r\n        var pointer, index = parseInt(pointerIndex), opts= {}, className; //TODO, parseInt only get the first index of pointerIndex array, a = [1,2], parseInt(a) = 1, currently we only support 1D, so it is ok\r\n\r\n        //for dictionary, we can not simply parseInt to get the pointerIndex\r\n        if (pointerVar.type == \"Idict\" || pointerVar.type == \"dict\"){\r\n            //dict is implemented by matrix, but pointer does not support targetindex for matrix now, leave it here\r\n            //TODO: future improvelement, change dict to linkedlist\r\n        }\r\n        var listType = [\"Ilist\", \"list\", \"Stack\", \"Queue\", \"set\", \"tuple\"];\r\n        if (isNaN(index) || listType.indexOf(pointerVar.type) == -1) {\r\n            if(listType.indexOf(pointerVar.type) == -1){\r\n                pointerName += \"[\"+index+\"]\";\r\n            }\r\n\r\n            //if index is not specified, it will point to the middle\r\n            //opts = {\"anchor\": \"left top\", \"myAnchor\": \"right bottom\",\"left\": -15, \"top\": -10};\r\n            opts = {\"depth\": depth, \"index\": pointerIndex};\r\n            className = \"myObjPointer\";\r\n\r\n            //store in list, add at last in one go\r\n            //..............................0.............1.......2........3..........4.................5\r\n            glbpointerParamList.push([variable.name, labelObj, opts, className, \"depth_\"+depthNo, pointerName]);\r\n        }else{\r\n            //opts = {\"targetIndex\": index, \"anchor\": \"center top\", \"myAnchor\": \"center bottom\", \"left\": -20, \"top\": -10};\r\n            opts = {\"targetIndex\": index, \"anchor\": \"left top\", \"myAnchor\": \"center bottom\"}; //TODO jquery 1.9.1 or above does not support this left. top, so we just use anchor here, to be fixed in the future\r\n//            pointer = av.pointer(variable.name, pointerObj, opts);\r\n//            pointer.addClass(\"myIndexPointer\");\r\n            className = \"myIndexPointer\";\r\n\r\n            //store in list, add at last in one go\r\n            //..............................0.............1.......2........3..........4.................5\r\n            glbpointerParamList.push([variable.name, pointerObj, opts, className, \"depth_\"+depthNo, pointerName]);\r\n        }\r\n\r\n//        return pointer;\r\n        return null;\r\n    }\r\n    return null;\r\n}\r\n/*\r\neg:  ['\"a\"'] -> a, because index has quotes inside brackets\r\n */\r\n//function trimQuotes(str){\r\n//    return str.substr(1,str.length-2).replace(/\\\"/g, \"\").replace(/\\'/g, \"\");\r\n//}\r\n\r\n//function removeEmptyElementFromArray(array){\r\n//    for (var i =array.length-1; i>=0; i--){\r\n//        if (array[i]=='')\r\n//            array.splice(i,1);\r\n//    }\r\n//}\r\n\r\n//[x, y, r, s, t, \"u\", [1,2], v, w] -> 2D array\r\n//recursion!!!\r\n//use comma as the delimiter\r\n//TODO: can not handle list and dictionary combination, currently, it is ok.\r\nfunction strToArray(str){\r\n    var result = [];\r\n\r\n    if (str[0] != \"[\" || str.slice(-1) != \"]\"){\r\n        return null;\r\n    }\r\n\r\n    for(var i=1; i<str.length-1; i++){\r\n        switch (str[i]){\r\n            case '[':\r\n                //Read until next \"]\"\r\n                var optStack = ['['], token = \"[\";\r\n                i++;\r\n                while(optStack.length != 0){\r\n                    if (i >= str.length -1){\r\n                        return null;\r\n                    }\r\n                    if (str[i] == \"[\"){\r\n                        optStack.push(optStack);\r\n                    }else if(str[i] == \"]\"){\r\n                        optStack.pop();\r\n                    }\r\n                    token += str[i++];\r\n                }\r\n                result.push(strToArray(token));\r\n                //reset i\r\n                i--;\r\n                break;\r\n            case ']':\r\n                return null;\r\n            default:\r\n                var token = \"\";\r\n                while(str[i] != '[' && str[i] != ']' && str[i] != \",\" && i<str.length-1){\r\n                    token += str[i++];\r\n                }\r\n                result.push(token.trim());\r\n                //reset i\r\n                if (str[i] != \",\"){\r\n                    i--;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n\r\n//{'a': [1,2], 'b': 2, c: {'a': 1, 'b': 2}} -> 2D dict\r\n//recursion!!!\r\n//use comma as the delimiter\r\n//TODO: Currently only handle 1D dictionary\r\nfunction strToDict(str){\r\n    /*  currently, add quotes to all keys and values.\r\n        JSON.parse will raise error if key is not recognized as string, so we need to add quotes\r\n    */\r\n    str = str.replace(/\\'/g, \"\\\"\");\r\n    //TODO, not finished. Now we change the jsoncontent from compiler, which we could avoid this conversion\r\n\r\n}\r\n\r\nvizJSAV.prototype.setCSSByClass=function(objclass,cssStr){\r\n    var objs = document.getElementsByClassName(objclass);\r\n    for (var i=0; i<objs.length;i++){\r\n        objs[i].css(cssStr);    \r\n    }\r\n}\r\n\r\n//indices is a list of elements to be highligted[1.2,3]\r\nvizJSAV.prototype.arrayHighlight=function(array, indices){\r\n    array.highlight(indices);\r\n}\r\nvizJSAV.prototype.arrayUnhighlight=function(array, indices){\r\n    array.unhighlight(indices);\r\n}\r\nvizJSAV.prototype.linkedListHighlight=function(linkedList, index){\r\n    linkedList.get(index).highlight();\r\n}\r\nvizJSAV.prototype.linkedListUnhighlight=function(linkedList, index){\r\n    linkedList.get(index).unhighlight();\r\n}\r\n\r\n\r\n/*\r\n    refresh flags and index highlights,\r\n    depth: depth_xxx\r\n */\r\nvizJSAV.prototype.refreshFlag = function(variable, depth){\r\n    //Assume varFlag is 0 and in jsavObjDict\r\n    var varName = variable.name,\r\n        varType = variable.type,\r\n        varFlag = variable.varFlag,\r\n        varPointer = variable.pointer;\r\n    var avVar;\r\n    if (jsavObjDict[depth][varName] == null || jsavObjDict[depth][varName].length == 0){\r\n        return;\r\n    }\r\n\r\n    avVar = jsavObjDict[depth][varName][0]; //0 is jsavObj, index 1 is label object\r\n\r\n    //if it is pointer, not need to refresh\r\n    if (varPointer != null && varPointer.length != 0){\r\n        //refresh the position\r\n        return;\r\n    }\r\n\r\n    switch (varType){\r\n        case \"int\": case \"str\": case \"bool\":case \"float\":case \"NoneType\":\r\n            //Need to redraw it!!! even varFlag is 0, value may changed\r\n            /*\r\n            for i ..\r\n                for j....\r\n                    i ,j here value changed, but flag is 0\r\n             */\r\n            avVar.hide();\r\n            varValue = variable.value;\r\n            var statusStr = varType + \"(\" + varName.trim() +\"): \" + varValue;\r\n            avVar = av.code(statusStr, {lineNumbers: false});\r\n            if (varFlag == glbFlags[\"c\"]){\r\n                avVar.css(0, {\"background-color\": cColor});\r\n            }else if(varFlag == glbFlags[\"n\"]){\r\n                avVar.css(0, {\"background-color\": nColor});\r\n            }else{\r\n                avVar.css(0, {\"background-color\":  uColor}); //empty the color\r\n            }\r\n            avVar.addClass(\"primitive\");\r\n            jsavObjDict[depth][varName][0] = avVar;\r\n            break;\r\n        case \"Idict\":case \"dict\":\r\n            this.clearDictFlags(avVar, variable);\r\n            break;\r\n        case \"Ilist\":case \"list\": case \"set\":case \"tuple\":case \"Stack\":case \"Queue\":\r\n            this.clearListFlags(avVar, variable);\r\n            break;\r\n        case \"LinkedList\":\r\n            this.clearLinkedListFlags(avVar, variable);\r\n            break;\r\n        case \"Matrix\":\r\n            this.clearMatrixFlags(avVar, variable);\r\n            break;\r\n        case \"StringMatrix\":\r\n            this.clearStringMatrixFlags(avVar, variable);\r\n            break;\r\n        case \"Graph\":case \"DiGraph\":\r\n            //no flags and index\r\n            break;\r\n        case \"RBTree\":\r\n            break;\r\n        case \"BinarySearchTree\":case \"AVLTree\":\r\n            this.clearBTreeFlags(avVar, variable);\r\n            break;\r\n        case \"BinaryMinHeap\":case \"MinPriorityQueue\":\r\n            this.clearHeapFlags(avVar, variable);\r\n            break;\r\n        case \"DisjointSet\":\r\n            this.clearDisjoinSetFlags(avVar, variable);\r\n            break;\r\n        case \"None\":\r\n            break;\r\n        default:\r\n            avVar.hide();\r\n            varValue = variable.value;\r\n            var varPointer = variable.pointer;\r\n            if (varPointer != null && varPointer.length > 0){\r\n                avVar = this.addPointer(variable, depth);\r\n            }else {\r\n                var statusStr;\r\n                if (varType != null) {\r\n                    statusStr = varType + \"(\" + varName.trim() + \"): \" + varValue;\r\n                } else {\r\n                    statusStr = varName.trim() + \": \" + varValue;\r\n                }\r\n                avVar = av.code(statusStr, {lineNumbers: false});\r\n                if (varFlag == glbFlags[\"c\"]) {\r\n                    avVar.css(0, {\"background-color\": cColor});\r\n                } else if (varFlag == glbFlags[\"n\"]) {\r\n                    avVar.css(0, {\"background-color\": nColor});\r\n                } else {\r\n                    avVar.css(0, {\"background-color\": uColor});\r\n                }\r\n                avVar.addClass(\"Others\");\r\n            }\r\n            jsavObjDict[depth][varName][0] = avVar;\r\n            break;\r\n    }\r\n}\r\n\r\n/*\r\n    return: [jsav data structure object/Pointer, jsav label object] label object may be null\r\n    depth: depth_xxx\r\n */\r\nvizJSAV.prototype.plotVar = function(variable, depth){\r\n\r\n    //varFlags could be null or 1 or 2\r\n    var varType = variable.type,\r\n        varName = variable.name,\r\n        varFlag = variable.varFlag,//maybe null for function return\r\n        varValue,\r\n        avVar,\r\n        avLabel,\r\n        avVarList = jsavObjDict[depth][varName];\r\n\r\n\r\n    //TODO: in the future, we will not create new JSAV objects if varFlag is 2, just change the contents based on flags.\r\n    if (avVarList != null){\r\n        for (var i=0; i<avVarList.length; i++){\r\n            if (avVarList[i] != null){\r\n                avVarList[i].hide();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    //If type is None, ignore. (None is not NoneType)\r\n    switch (varType){\r\n        case \"int\": case \"str\": case \"bool\":case \"float\":case \"NoneType\":\r\n            varValue = variable.value;\r\n            var statusStr = varType + \"(\" + varName.trim() +\"): \" + varValue;\r\n            avVar = av.code(statusStr, {lineNumbers: false});\r\n            if (varFlag == glbFlags[\"c\"]){\r\n                avVar.css(0, {\"background-color\": cColor});\r\n            }else if(varFlag == glbFlags[\"n\"]){\r\n                avVar.css(0, {\"background-color\": nColor});\r\n            }\r\n            avVar.addClass(\"primitive\");\r\n            break;\r\n\r\n        case \"Idict\":case \"dict\": //TODO: use 2D linkedlist for visualization\r\n            //TODO Check pointer and varFlag first\r\n            var varPointer = variable.pointer;\r\n            if (varPointer != null && varPointer.length > 0){\r\n                avVar = this.addPointer(variable, depth);\r\n            }else{\r\n                avLabel = av.label(variable.name);\r\n                avVar = this.parseDict(variable);\r\n                avVar.addClass(\"Idict\");\r\n            }\r\n            break;\r\n        case \"Ilist\":case \"Array\": case \"set\":case \"tuple\": //TODO: Support 2D array\r\n            //TODO Check pointer and varFlag first\r\n            var varPointer = variable.pointer;\r\n            if (varPointer != \"None\" && varPointer.length > 0){\r\n                avVar = this.addPointer(variable, depth);\r\n            }else{\r\n                avLabel = av.label(variable.name);\r\n                avVar= this.parseList(variable, {});\r\n                avVar.addClass(\"Ilist\");\r\n    //            avLabel = labelPointer(variable.name, avVar);\r\n            }\r\n            break;\r\n        case \"Stack\":\r\n            var varPointer = variable.pointer;\r\n            if (varPointer != null && varPointer.length > 0){\r\n                avVar = this.addPointer(variable, depth);\r\n            }else {\r\n                avLabel = av.label(variable.name);\r\n                avVar = this.parseList(variable, {layout: \"vertical\", indexed: true});\r\n                avVar.addClass(\"Stack\");\r\n//            avLabel = labelPointer(variable.name, avVar);\r\n            }\r\n            break;\r\n        case \"Queue\":\r\n            var varPointer = variable.pointer;\r\n            if (varPointer != null && varPointer.length > 0){\r\n                avVar = this.addPointer(variable, depth);\r\n            }else{\r\n                avLabel = av.label(variable.name);\r\n                avVar= this.parseList(variable, {indexed: true});\r\n                avVar.addClass(\"Queue\");\r\n    //            avLabel = labelPointer(variable.name, avVar);\r\n            }\r\n            break;\r\n        case \"LinkedList\":\r\n            var varPointer = variable.pointer;\r\n            if (varPointer != null && varPointer.length > 0){\r\n                avVar = this.addPointer(variable, depth);\r\n            }else{\r\n                avLabel = av.label(variable.name);\r\n                avVar= this.parseLinkedList(variable);\r\n                avVar.addClass(\"LinkedList\");\r\n    //            avLabel = labelPointer(variable.name, avVar);\r\n            }\r\n            break;\r\n        case \"Matrix\":\r\n            var varPointer = variable.pointer;\r\n            if (varPointer != null && varPointer.length > 0){\r\n                avVar = this.addPointer(variable, depth);\r\n            }else{\r\n                avLabel = av.label(variable.name);\r\n                avVar= this.parseMatrix(variable);\r\n                avVar.addClass(\"Matrix\");\r\n    //            avLabel = labelPointer(variable.name, avVar);\r\n            }\r\n            break;\r\n        case \"StringMatrix\":\r\n            var varPointer = variable.pointer;\r\n            if (varPointer != null && varPointer.length > 0){\r\n                avVar = this.addPointer(variable, depth)\r\n            }else{\r\n                avLabel = av.label(variable.name);\r\n                avVar= this.parseStringMatrix(variable);\r\n                avVar.addClass(\"StringMatrix\");\r\n    //            avLabel = labelPointer(variable.name, avVar);\r\n            }\r\n            break;\r\n        case \"Graph\":\r\n            var varPointer = variable.pointer;\r\n            if (varPointer != null && varPointer.length > 0){\r\n                avVar = this.addPointer(variable, depth);\r\n            }else {\r\n                avLabel = av.label(variable.name);\r\n                avVar = this.parseGraph(variable, {layout: \"layered\"});\r\n                avVar.addClass(\"Graph\");\r\n//            avLabel = labelPointer(variable.name, avVar);\r\n            }\r\n            break;\r\n        case \"DiGraph\":\r\n            var varPointer = variable.pointer;\r\n            if (varPointer != null && varPointer.length > 0){\r\n                avVar = this.addPointer(variable, depth);\r\n            }else {\r\n                avLabel = av.label(variable.name);\r\n                avVar = this.parseGraph(variable, {directed: true, layout: \"layered\"});\r\n                avVar.addClass(\"DiGraph\");\r\n//            avLabel = labelPointer(variable.name, avVar);\r\n            }\r\n            break;\r\n        case \"BinarySearchTree\":\r\n            var varPointer = variable.pointer;\r\n            if (varPointer != null && varPointer.length > 0){\r\n                avVar = this.addPointer(variable, depth);\r\n            }else {\r\n                avLabel = av.label(variable.name);\r\n                avVar = this.parseBTree(variable, \"BinarySearchTree\");\r\n                avVar.addClass(\"BinarySearchTree\");\r\n//            avLabel = labelPointer(variable.name, avVar);\r\n            }\r\n            break;\r\n        case \"AVLTree\":\r\n            var varPointer = variable.pointer;\r\n            if (varPointer != null && varPointer.length > 0){\r\n                avVar = this.addPointer(variable, depth);\r\n            }else {\r\n                avLabel = av.label(variable.name);\r\n                avVar = this.parseBTree(variable, \"AVLTree\");\r\n                avVar.addClass(\"AVLTree\");\r\n//            avLabel = labelPointer(variable.name, avVar);\r\n            }\r\n            break;\r\n        case \"RBTree\":\r\n            var varPointer = variable.pointer;\r\n            if (varPointer != null && varPointer.length > 0){\r\n                avVar = this.addPointer(variable, depth);\r\n            }else {\r\n                avLabel = av.label(variable.name);\r\n                avVar = this.parseBTree(variable, \"RBTree\");\r\n                avVar.addClass(\"RBTree\");\r\n//            avLabel = labelPointer(variable.name, avVar);\r\n            }\r\n            break;\r\n        case \"BinaryMinHeap\":\r\n            var varPointer = variable.pointer;\r\n            if (varPointer != null && varPointer.length > 0){\r\n                avVar = this.addPointer(variable, depth);\r\n            }else {\r\n                avLabel = av.label(variable.name);\r\n                avVar = this.parseHeap(variable);\r\n                avVar.addClass(\"BinaryMinHeap\");\r\n//            avLabel = labelPointer(variable.name, avVar);\r\n            }\r\n            break;\r\n        case \"MinPriorityQueue\":\r\n            var varPointer = variable.pointer;\r\n            if (varPointer != null && varPointer.length > 0){\r\n                avVar = this.addPointer(variable, depth);\r\n            }else {\r\n                avLabel = av.label(variable.name);\r\n                avVar = this.parseHeap(variable);\r\n                avVar.addClass(\"MinPriorityQueue\");\r\n//            avLabel = labelPointer(variable.name, avVar);\r\n            }\r\n            break;\r\n        case \"DisjointSet\":\r\n            var varPointer = variable.pointer;\r\n            if (varPointer != null && varPointer.length > 0){\r\n                avVar = this.addPointer(variable, depth);\r\n            }else {\r\n                avLabel = av.label(variable.name);\r\n                avVar = this.parseDisjointSet(variable);\r\n                avVar.addClass(\"DisjointSet\");\r\n//            avLabel = labelPointer(variable.name, avVar);\r\n            }\r\n            break;\r\n\r\n        case \"None\":\r\n            break;\r\n        default:\r\n            varValue = variable.value;\r\n            var varPointer = variable.pointer;\r\n            if (varPointer != null && varPointer.length > 0){\r\n                avVar = this.addPointer(variable, depth);\r\n            }else {\r\n                var statusStr;\r\n                if (varType != null) {\r\n                    statusStr = varType + \"(\" + varName.trim() + \"): \" + varValue;\r\n                } else {\r\n                    statusStr = varName.trim() + \": \" + varValue;\r\n                }\r\n                avVar = av.code(statusStr, {lineNumbers: false});\r\n                if (varFlag == glbFlags[\"c\"]) {\r\n                    avVar.css(0, {\"background-color\": cColor});\r\n                } else if (varFlag == glbFlags[\"n\"]) {\r\n                    avVar.css(0, {\"background-color\": nColor});\r\n                } else {\r\n                    avVar.css(0, {\"background-color\": uColor});\r\n                }\r\n                avVar.addClass(\"Others\");\r\n            }\r\n            break;\r\n    }\r\n    return [avVar, avLabel];\r\n}\r\n\r\n//pointer for variable labels, not used\r\nfunction labelPointer(name, jsavObj) {\r\n    var pointer = av.pointer(name, jsavObj);\r\n    return pointer;\r\n}\r\n\r\n//TODO: parseList can invoke this function, code reuse!!!\r\nvizJSAV.prototype.clearListFlags = function (avVar, variable) {\r\n    var flagsList = variable.flags,\r\n        varIndex = variable.index;\r\n\r\n    //Highlight index and changed elements\r\n    if (flagsList != null){ //tuple and set do not have flags\r\n        for (var i = 0; i < flagsList.length; i++) {\r\n            //only highlight when value changed\r\n            if (flagsList[i] == glbFlags['c']) { // \"2\" == 2 true\r\n                avVar.css(i, {\"background-color\": cColor});\r\n            } else if (flagsList[i] == glbFlags['n']) {\r\n                avVar.css(i, {\"background-color\": nColor});\r\n            }else{\r\n                avVar.css(i, {\"background-color\":  uColor});\r\n            }\r\n        }\r\n    }\r\n\r\n    if (varIndex != null && varIndex.length != 0){\r\n        var index = parseInt(varIndex[0]);\r\n        avVar.css(index, {\"background-color\": indexColor});\r\n    }\r\n\r\n}\r\nvizJSAV.prototype.parseList=function(variable, options) {\r\n    var valueList = variable.value,\r\n        varIndex = variable.index,//an array with string index, TODO currently assume the length is 1, in other words, 1D list\r\n        flagsList = variable.flags;\r\n\r\n    var avVar = av.ds.array(valueList, options);//TODO: to support multi-dimensional array, split based on brackets stack is needed.Changes on compiler flags array is also required.\r\n\r\n    //Highlight index and changed elements\r\n    if (flagsList != null){ //tuple and set do not have flags\r\n        for (var i = 0; i < flagsList.length; i++) {\r\n            //only highlight when value changed\r\n            if (flagsList[i] == glbFlags['c']) { // \"2\" == 2 true\r\n                avVar.css(i, {\"background-color\": cColor});\r\n            } else if (flagsList[i] == glbFlags['n']) {\r\n                avVar.css(i, {\"background-color\": nColor});\r\n            }\r\n        }\r\n    }\r\n\r\n    if (varIndex != null && varIndex.length != 0){\r\n        var index = parseInt(varIndex[0]);\r\n        avVar.css(index, {\"background-color\": indexColor});\r\n    }\r\n\r\n    avVar.mouseenter(avVar.highlight).mouseleave(avVar.unhighlight);\r\n    return avVar;\r\n    \r\n}\r\n\r\nvizJSAV.prototype.clearMatrixFlags = function(avVar, variable){\r\n    //matrix has no flags\r\n}\r\n\r\nvizJSAV.prototype.parseMatrix = function(variable){\r\n    //no flags for matrix\r\n    var matrixName = variable.name,\r\n        matrixArr =variable.value;\r\n\r\n    var avVar = av.ds.matrix(matrixArr, {style: \"matrix\"});\r\n    avVar.layout();\r\n    return avVar;\r\n}\r\n\r\nvizJSAV.prototype.clearStringMatrixFlags = function (avVar, variable) {\r\n    var flagsArr = variable.flags,\r\n        topheader = variable.topheader,\r\n        leftheader = variable.leftheader,\r\n        varIndex = variable.index; //TODO not used currently\r\n\r\n    var hasHeader = (topheader.length != 0 || leftheader.length != 0);\r\n\r\n     //highlight element based on flags\r\n    for (var i=0; i<flagsArr.length; i++){\r\n        for (var j=0; j<flagsArr[i].length; j++){\r\n            if (flagsArr[i][j] == glbFlags['c']){\r\n                if(hasHeader){\r\n                    avVar.css(i+1,j+1,{\"background-color\": cColor});\r\n                }else{\r\n                    avVar.css(i,j,{\"background-color\": cColor});\r\n                }\r\n\r\n            }else if(flagsArr[i][j] == glbFlags['n']){\r\n                if(hasHeader){\r\n                    avVar.css(i+1,j+1,{\"background-color\": nColor});\r\n                }else{\r\n                    avVar.css(i,j,{\"background-color\": nColor});\r\n                }\r\n            }else{\r\n                if(hasHeader){\r\n                    avVar.css(i+1,j+1,{\"background-color\":  uColor});\r\n                }else{\r\n                    avVar.css(i,j,{\"background-color\":  uColor});\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvizJSAV.prototype.parseStringMatrix=function(variable){\r\n    var matrixArr = variable.value,\r\n        flagsArr = variable.flags,\r\n        edgesArr = variable.edges,\r\n        topheaderObj = $.extend(true, {}, variable.topheader),\r\n        leftheaderObj = $.extend(true, {}, variable.leftheader),\r\n        varIndex = variable.index; //TODO not used currently\r\n\r\n    //deepcopy topHeader\r\n    var topheader = $.map(topheaderObj, function(value, index) {\r\n        return [value];\r\n    });\r\n\r\n    //deepcopy leftHeader\r\n    var leftheader = $.map(leftheaderObj, function(value, index) {\r\n        return [value];\r\n    });\r\n\r\n\r\n//    var hasHeader = (topheader != [] || leftheader != []);// illegal !!! [] != []\r\n    var hasHeader = (topheader.length != 0 || leftheader.length != 0); //topheader changed below, this will cause topheader != [] true here.\r\n\r\n    //var newMatrixArr = matrixArr;//matrix array with headers, need to use deepcopy here, otherwise it will change the variable value\r\n    var newMatrixObj = $.extend(true, {}, matrixArr);//deep copy returns a dict object, need to convert to array\r\n    var newMatrixArr = $.map(newMatrixObj, function(value, index) {\r\n        return [value];\r\n    });\r\n\r\n    if (hasHeader){\r\n        //unshift or splice, both are ok\r\n\r\n        ////if topheader length != cols, append empty strings to it\r\n        //for (var i=topheader.length; i<newMatrixArr[0].length; i++){\r\n        //    topheader[i] = \"\";\r\n        //}\r\n        //newMatrixArr.unshift(topheader);//add to the front\r\n        ////add left header line by line\r\n        //newMatrixArr[0].unshift(\"\");//top-left corner should be empty\r\n        //\r\n        //for (var i=1; i<newMatrixArr.length; i++){\r\n        //    newMatrixArr[i].unshift(leftheader[i-1]); //if leftheader[i-1] is undefined, the program will simply leave that cell blank\r\n        //}\r\n\r\n        //if topheader length != cols, add empty strings to the front\r\n        for (var i=topheader.length; i<newMatrixArr[0].length; i++){\r\n            topheader.splice(0,0, \"\");\r\n        }\r\n        for (var i=leftheader.length; i<newMatrixArr.length; i++){\r\n            leftheader.splice(0,0, \"\");\r\n        }\r\n        newMatrixArr.splice(0,0,topheader);//add to the front\r\n        //add left header line by line\r\n        newMatrixArr[0].splice(0, 0, \"\");//top-left corner should be empty\r\n\r\n        for (var i=1; i<newMatrixArr.length; i++){\r\n            newMatrixArr[i].splice(0,0,leftheader[i-1]); //if leftheader[i-1] is undefined, the program will simply leave that cell blank\r\n        }\r\n\r\n    }\r\n\r\n    var avVar = av.ds.matrix(newMatrixArr, {style: \"plain\"});\r\n\r\n    //gray the header\r\n    if (hasHeader){\r\n        for (var i=1; i<newMatrixArr[0].length; i++){\r\n            avVar.css(0, i, {\"background-color\": matrixHeaderColor});\r\n        }\r\n        for (var i=1; i<newMatrixArr.length; i++){\r\n            avVar.css(i, 0, {\"background-color\": matrixHeaderColor});\r\n        }\r\n    }\r\n\r\n    //highlight element based on flags\r\n    for (var i=0; i<flagsArr.length; i++){\r\n        for (var j=0; j<flagsArr[i].length; j++){\r\n            if (flagsArr[i][j] == glbFlags['c']){\r\n                if(hasHeader){\r\n                    avVar.css(i+1,j+1,{\"background-color\": cColor});\r\n                }else{\r\n                    avVar.css(i,j,{\"background-color\": cColor});\r\n                }\r\n\r\n            }else if(flagsArr[i][j] == glbFlags['n']){\r\n                if(hasHeader){\r\n                    avVar.css(i+1,j+1,{\"background-color\": nColor});\r\n                }else{\r\n                    avVar.css(i,j,{\"background-color\": nColor});\r\n                }\r\n            }\r\n        }\r\n    }\r\n    //Add edges\r\n    for (var i=0; i<edgesArr.length; i++){\r\n        //addEdge(a,b,c,d), if one of the node is flag c or n, change edge color\r\n        var a = parseInt(edgesArr[i][0]),\r\n            b = parseInt(edgesArr[i][1]),\r\n            c = parseInt(edgesArr[i][2]),\r\n            d = parseInt(edgesArr[i][3]),\r\n            opts = {};\r\n        if ((a<flagsArr.length && b<flagsArr[a].length && c<flagsArr.length && d<flagsArr[c].length) &&\r\n                (flagsArr[a][b] == glbFlags['c'] || flagsArr[c][d] == glbFlags['c'])){\r\n            opts = $.extend({\"stroke\": edgeColor});\r\n        }\r\n        if (hasHeader){\r\n            a++; b++; c++; d++;\r\n        }\r\n\r\n        avVar.addEdge(a,b,c,d,opts);\r\n    }\r\n\r\n    avVar.layout();\r\n    return avVar;\r\n}\r\n\r\nvizJSAV.prototype.clearDictFlags=function(avVar, variable){\r\n    //TODO didn't consider the index\r\n    var flagsDict = variable.flags,\r\n        varIndex = variable.index;\r\n    var indexKey;\r\n    if (varIndex != null && varIndex.length != 0){\r\n        indexKey = varIndex[0];\r\n    }\r\n\r\n    var count = 1; //index 0 is key and val header\r\n    for(var key in flagsDict){\r\n        //highlight when value changed\r\n        if (flagsDict[key] == glbFlags['c']){\r\n            avVar.css(0, count, {\"background-color\": cColor});\r\n            avVar.css(1, count, {\"background-color\": cColor});\r\n        }else if (flagsDict[key] == glbFlags['n']){\r\n            avVar.css(0, count, {\"background-color\": nColor});\r\n            avVar.css(1, count, {\"background-color\": nColor});\r\n        }else{\r\n            avVar.css(0, count, {\"background-color\":  uColor});\r\n            avVar.css(1, count, {\"background-color\":  uColor});\r\n        }\r\n        if (key == indexKey){\r\n            avVar.css(0, count, {\"background-color\": indexColor});\r\n            avVar.css(1, count, {\"background-color\": indexColor});\r\n        }\r\n        count++;\r\n    }\r\n\r\n}\r\n\r\nvizJSAV.prototype.parseDict=function(variable){\r\n    var valDict=variable.value, flagsDict=variable.flags,\r\n        varIndex = variable.index;//an array\r\n\r\n    var index = -1;//index of varIndex in dict\r\n\r\n    var nCols = valDict.length;\r\n    var nRows = 2;\r\n\r\n    var matrix = new Array();\r\n    var firstRow = new Array(\"Key\");\r\n    var secondRow = new Array(\"Val\");\r\n    var count = 1;\r\n    for(var key in valDict){\r\n        firstRow.push(key);\r\n        secondRow.push(valDict[key]);\r\n\r\n        if (varIndex != null && varIndex.length != 0 && varIndex[0] == key){\r\n            index = count;\r\n        }\r\n        count++;\r\n    }\r\n\r\n    matrix.push(firstRow);\r\n    matrix.push(secondRow);\r\n\r\n    var avVar = av.ds.matrix(matrix);\r\n\r\n    //Highlight index and changed elements\r\n    count = 1; //reset count\r\n    for(var key in flagsDict){\r\n        //highlight when value changed\r\n        if (flagsDict[key] == glbFlags['c']){\r\n            avVar.css(0, count, {\"background-color\": cColor});\r\n            avVar.css(1, count, {\"background-color\": cColor});\r\n        }else if (flagsDict[key] == glbFlags['n']){\r\n            avVar.css(0, count, {\"background-color\": nColor});\r\n            avVar.css(1, count, {\"background-color\": nColor});\r\n        }\r\n        count++;\r\n    }\r\n\r\n    //index has higher priority than flags\r\n    if (index != -1){\r\n        avVar.css(0, index, {\"background-color\": indexColor});\r\n        avVar.css(1, index, {\"background-color\": indexColor});\r\n    }\r\n\r\n    return avVar;\r\n}\r\n\r\nvizJSAV.prototype.clearLinkedListFlags= function (avVar, variable) {\r\n    var flagsList = variable.flags,\r\n        varIndex = variable.index;//an array\r\n\r\n    for (var i=0; i<flagsList.length; i++){\r\n        if (flagsList[i] == glbFlags[\"c\"]){\r\n            avVar.get(i).css({\"background-color\": cColor});\r\n        }else if(flagsList[i] == glbFlags[\"n\"]){\r\n            avVar.get(i).css({\"background-color\": nColor});\r\n        }else{\r\n            avVar.get(i).css({\"background-color\":  uColor});\r\n        }\r\n    }\r\n\r\n    if (varIndex != null && varIndex.length != 0) {//TODO only support 1D linkedlist\r\n        var index = parseInt(varIndex[0])\r\n        avVar.get(index).css({\"background-color\": indexColor});\r\n    }\r\n}\r\n\r\nvizJSAV.prototype.parseLinkedList=function(variable){\r\n    var flagsList = variable.flags,\r\n        varIndex = variable.index,//an array\r\n        valList = variable.value,\r\n        varName = variable.name;\r\n\r\n    var avVar = av.ds.list();\r\n\r\n    for (var i=0; i<valList.length; i++){\r\n\r\n        avVar.addLast(valList[i]);\r\n        if (flagsList[i] == glbFlags[\"c\"]){\r\n            avVar.get(i).css({\"background-color\": cColor});\r\n        }else if(flagsList[i] == glbFlags[\"n\"]){\r\n            avVar.get(i).css({\"background-color\": nColor});\r\n        }\r\n    }\r\n\r\n    if (varIndex != null && varIndex.length != 0) {//TODO only support 1D linkedlist\r\n        var index = parseInt(varIndex[0])\r\n        avVar.get(index).css({\"background-color\": indexColor});\r\n    }\r\n\r\n    avVar.layout();\r\n    return avVar;\r\n}\r\n\r\nvizJSAV.prototype.parseGraph=function(variable, options){\r\n    var vertexList = variable.V,\r\n        edgeList = variable.E;\r\n\r\n    var graph = av.ds.graph(options);\r\n\r\n    //Add nodes to graph\r\n    var vertexDict = {};\r\n    for(var i=0; i<vertexList.length; i++){\r\n        var vertex = vertexList[i].value,\r\n            color = vertexList[i].color.toUpperCase();\r\n        var node = graph.addNode(vertex);\r\n        node.css({\"background-color\": graphColor[color]});//change color depth, if not find in the dictionary, default is white\r\n        vertexDict[vertex] = node;\r\n    }\r\n\r\n    //Add edges to graph\r\n    for (var i=0; i<edgeList.length; i++){\r\n        var start = edgeList[i].start,\r\n            end = edgeList[i].end,\r\n            color = edgeList[i].color,\r\n            weight = edgeList[i].weight;\r\n        graph.addEdge(vertexDict[start], vertexDict[end], {\"weight\": weight, \"stroke\": color});\r\n    }\r\n\r\n    graph.layout();\r\n    return graph;\r\n}\r\n\r\nvizJSAV.prototype.clearBTreeFlags = function (avVar, variable) {\r\n    /*\r\n        Simply remove all the color's of tree nodes\r\n     */\r\n    var root = avVar.root();\r\n    this.clearBTreeNodeColor(root);\r\n}\r\n\r\nvizJSAV.prototype.clearBTreeNodeColor = function(node){\r\n    node.css({\"background-color\":  uColor});\r\n    if (node.left()){\r\n        this.clearBTreeNodeColor(node.left());\r\n    }\r\n    if (node.right()){\r\n        this.clearBTreeNodeColor(node.right());\r\n    }\r\n}\r\n\r\nvizJSAV.prototype.parseBTree=function(variable, treeType){\r\n    var tree = av.ds.binarytree();\r\n    var varIndex = variable.index, //currently do not support index for BST\r\n        varFlags = variable.flags,\r\n        varValue = variable.value,\r\n        rbValue = variable.color;\r\n    var rbArr;\r\n    if (treeType == \"RBTree\"){\r\n        rbArr = rbValue.replace(/\\[/g,\" \").replace(/\\]/g,\" \").match(/\\S+/g); //split by space\r\n    }\r\n\r\n    var flagsArr = varFlags.replace(/\\[/g,\" \").replace(/\\]/g,\" \").match(/\\S+/g); //split by space\r\n    var optStack = [];\r\n    var nodeStack = [];\r\n    var token = \"\";\r\n    var node;\r\n    var str = varValue;\r\n    var tempLast;\r\n    var nodeCount = 0;\r\n    for (var i=0; i<str.length;i++){\r\n        switch(str[i]){\r\n            //[9[8][10]]\r\n            case '[':\r\n                optStack.push(str[i]);\r\n                //alert(\"new node start!\");\r\n                break;\r\n            case ']':\r\n                //alert(\"a node closed!\");\r\n                optStack.pop();\r\n                if (optStack.length==0){\r\n                    node=nodeStack.pop();\r\n                    tree.root(node);\r\n                    //alert(node.value());\r\n                }else{\r\n                    node=nodeStack.pop();\r\n                    if (node == null){\r\n                        continue;\r\n                    }\r\n                    //alert(node.value());\r\n                    tempLast=nodeStack.length-1;\r\n\r\n                    if (parseInt(node.value())<parseInt(nodeStack[tempLast].value())){ //without parseint 10 < 9\r\n                        nodeStack[tempLast].left(node);\r\n                    }else{\r\n                        nodeStack[tempLast].right(node);\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                while(str[i]!='[' && str[i]!=']' && i<str.length){\r\n                   token=token+str[i];\r\n                   i=i+1;\r\n                }\r\n                token = token.trim().replace(/\\'/g, \"\").replace(/\\\"/g, \"\");\r\n                if (token!=\"None\"){\r\n                    node = tree.newNode(token);\r\n                    if (flagsArr[nodeCount] >=3){\r\n                        node.css({\"border-color\": bColor, \"border-width\": \"2px\"});\r\n                        flagsArr[nodeCount] -= 3\r\n                    }\r\n                    if (treeType == \"RBTree\"){\r\n                        if (rbArr[nodeCount] == \"R\"){\r\n                            node.css({\"background-color\": graphColor[\"RED\"]});\r\n                        }else if(rbArr[nodeCount] == \"B\"){\r\n                            node.css({\"color\":\"white\",\"background-color\": \"BLACK\"});\r\n                        }\r\n                    }else{\r\n                        if (flagsArr[nodeCount] == glbFlags[\"n\"]){\r\n                            node.css({\"background-color\": nColor});\r\n                        }else if(flagsArr[nodeCount] == glbFlags[\"c\"]){\r\n                            node.css({\"background-color\": cColor});\r\n                        }\r\n                    }\r\n\r\n\r\n                    nodeStack.push(node);\r\n                    //alert(node.value()+\" is created!\");\r\n                }else{\r\n                    nodeStack.push(null);\r\n                }\r\n                nodeCount++;\r\n                token=\"\";//reset token\r\n                i=i-1;//reset i\r\n                break;\r\n        }\r\n    }\r\n    tree.layout();\r\n    return tree;\r\n}\r\n\r\nvizJSAV.prototype.clearHeapFlags=function(avVar, variable) {\r\n    //TODO to be completed\r\n\r\n}\r\n\r\n//complete binary tree\r\nvizJSAV.prototype.parseHeap=function(variable){\r\n    var tree = av.ds.binarytree();\r\n    var varIndex = variable.index, //currently do not support index for Heap\r\n        flagsArr = variable.flags,\r\n        valArr = variable.value,\r\n        nodeList = [];\r\n\r\n\r\n    for (var i=0; i<valArr.length; i++){\r\n        var newNode = tree.newNode(valArr[i]);\r\n         if (flagsArr[i] == glbFlags[\"n\"]){\r\n            newNode.css({\"background-color\": nColor});\r\n        }else if(flagsArr[i] == glbFlags[\"c\"]){\r\n            newNode.css({\"background-color\": cColor});\r\n        }\r\n        nodeList.push(newNode);\r\n        if (i == 0){\r\n            tree.root(newNode);\r\n        }else{\r\n            var parentIndex = parseInt((i-1)/2);\r\n            if (i%2 == 0){//right node\r\n                nodeList[parentIndex].right(newNode);\r\n            }else{//left node\r\n                nodeList[parentIndex].left(newNode);\r\n            }\r\n        }\r\n    }\r\n\r\n    tree.layout();\r\n    return tree;\r\n}\r\n\r\nvizJSAV.prototype.clearDisjoinSetFlags = function (avVar, varible) {\r\n    //TODO to be completed\r\n}\r\n\r\nvizJSAV.prototype.parseDisjointSet=function(variable){\r\n\r\n    var tree = av.ds.tree();\r\n    var varIndex = variable.index, //currently do not support index for disjointset\r\n        valDict = variable.value,\r\n        flagDict = variable.flags,\r\n        nodeDict = {};\r\n\r\n    //First add a invisible root node\r\n    var root = tree.root();\r\n    root.hide({\"recursive\": false});\r\n\r\n    for (var key in valDict){\r\n        var value = valDict[key];\r\n        if (!(key in nodeDict)){\r\n            var newNode = tree.newNode(key);\r\n            if (flagDict[key] == glbFlags[\"n\"]){\r\n                newNode.css({\"background-color\": nColor});\r\n            }else if(flagDict[key] == glbFlags[\"c\"]){\r\n                newNode.css({\"background-color\": cColor});\r\n            }\r\n            nodeDict[key] = newNode;\r\n        }\r\n        if (!(value in nodeDict)){\r\n            var newNode = tree.newNode(value);\r\n            if (flagDict[value] == glbFlags[\"n\"]){\r\n                newNode.css({\"background-color\": nColor});\r\n            }else if(flagDict[value] == glbFlags[\"c\"]){\r\n                newNode.css({\"background-color\": cColor});\r\n            }\r\n            nodeDict[value] = newNode;\r\n        }\r\n\r\n        if (key == value){ // independent set\r\n            root.addChild(nodeDict[key]);\r\n            //hide the edge to root\r\n            nodeDict[key].edgeToParent().hide();\r\n        }else{\r\n            nodeDict[value].addChild(nodeDict[key]);\r\n        }\r\n    }\r\n\r\n    tree.layout();\r\n    return tree;\r\n}\r\n\r\n\r\n/*\r\nfunction readTextFile(file)\r\n{\r\n    var xmlFile = new XMLHttpRequest();\r\n    xmlFile.open(\"GET\", file, false);\r\n    xmlFile.send(null);\r\n    var responsexml = xmlFile.responseXML;\r\n    return responsexml\r\n}\r\nvizJSAV.prototype.refresh = function()\r\n{\r\n    // read file\r\n    var xmldoc = readTextFile(\"varList.xml\");\r\n    \r\n    var varList = xmldoc.getElementsByTagName(\"var\");\r\n    for (var i = 0; i < varList.length; i ++)\r\n    {\r\n       var nodeTemp = varList[i].childNodes;\r\n       var varAttr=new arrary;\r\n       var varValue;\r\n       for (var j=0; j<nodeTemp.length;j++){\r\n            if (nodeTemp[j].nodeName==\"value\")\r\n                varValue=nodeTemp[j].nodeValue;\r\n            else if (nodeTemp[j].nodeName==\"attr\")\r\n                varAttr.push(nodeTemp[j]);\r\n       }\r\n       var varInfo = [varList[i].getAttribute(\"name\"),\r\n                  varList[i].getAttribute(\"type\"),\r\n                  varValue];\r\n        this.plotVar(varInfo, varAttr);\r\n    }\r\n}\r\n*/"],"sourceRoot":"/source/"}