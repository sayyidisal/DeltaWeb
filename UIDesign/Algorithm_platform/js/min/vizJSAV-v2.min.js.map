{"version":3,"sources":["vizJSAV-v2.js"],"names":["vizJSAV","divID","jsonObj","jsonContent","container","$","av","JSAV","document","getElementById","glbFlags","u","n","c","indexColor","nColor","cColor","bColor","edgeColor","matrixHeaderColor","uColor","graphColor","RED","BLUE","GRAY","WHITE","YELLOW","GREEN","BLACK","DATATYPES","current_content","current_line","currentStat","divDepthList","avDepthDict","prototype","animate","statementNo","statementLabel","depthList","layerCount","Object","keys","length","i","layer","append","avObj","containerWidth","width","padding","singleLayerWidth","css","depth","variableList","j","variable","name","this","plotVar","avVar","avLabel","varType","type","varName","varValue","value","statusStr","trim","code","lineNumbers","addClass","label","parseDict","parseDisjointSet","parseList","layout","indexed","parseLinkedList","parseHeap","parseTree","parseBTree","parseGraph","directed","parseMatrix","parseStringMatrix","valDict","matrix","Array","firstRow","secondRow","key","push","ds","mouseenter","highlight","mouseleave","unhighlight","tree","nodeDict","root","hide","recursive","newNode","addChild","edgeToParent","options","valueList","array","valList","list","addLast","binarytree","valArr","nodeList","parentIndex","parseInt","right","left","optStack","nodeStack","token","pop","node","parentNode","treeType","rbArr","rbValue","color","replace","match","tempLast","str","nodeCount","background-color","vertexList","V","edgeList","E","graph","vertexDict","vertex","toUpperCase","addNode","start","end","weight","addEdge","stroke","matrixArr","style","edgesArr","edges","topheaderObj","extend","topheader","leftheaderObj","leftheader","map","index","hasHeader","newMatrixObj","newMatrixArr","splice","a","b","d","opts"],"mappings":"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","file":"vizJSAV-v2.min.js","sourcesContent":["//replace ' by \" and JSON.parse()\n//Never change the variable object itself!!!, Use deepcopy everytime the program needs to change the content\n\nvar jsonContent = {};\nvar glbFlags = {\"u\" :0, \"n\": 1, \"c\": 2};\n\n//using highlight will not be overwritten by later css, so we do not use highlight\nvar indexColor = \"rgb(255, 163, 163)\",\n    nColor = \"rgb(217, 255, 178)\",\n    cColor = \"rgb(255, 255, 162)\",\n    bColor = \"red\",\n    edgeColor = \"rgb(255, 102, 255)\",\n    matrixHeaderColor = \"rgb(152,152,152)\",\n    uColor = \"white\";\n\nvar graphColor = {\n    \"RED\": \"rgb(217, 137, 137)\",\n    \"BLUE\": \"rgb(138, 138, 230)\",\n    \"GRAY\": \"rgb(204, 204, 204)\",\n    \"WHITE\": \"rgb(255, 255, 255)\",\n    \"YELLOW\": \"rgb(255, 255, 153)\",\n    \"GREEN\": \"rgb(162, 243, 162)\",\n    \"BLACK\": \"rgb(0, 0, 0)\"\n};\n\nvar DATATYPES = [\"Dict\", \"DisjointSet\", \"Array\", \"Stack\", \"Queue\", \"LinkedList\", \"BinaryMinHeap\", \"BinaryMaxHeap\", \"MinPriorityQueue\", \"MaxPriorityQueue\", \"Tree\",\n        \"BinarySearchTree\", \"AVLTree\", \"RBTree\", \"Graph\", \"DiGraph\", \"StringMatrix\",\n        \"int\", \"str\", \"bool\", \"float\", \"NoneType\"];\n\nvar av;\nvar current_content, current_line, currentStat; //statement_XX\nvar container; //container is the most outer div that contains all the layers\nvar divDepthList = [];//div element of each layer\nvar avDepthDict = {}; //depth_1 : av1 ....\n\n/***************************************Function definition********************************************/\n\n//init vizJSAV object here.\nfunction vizJSAV(divID, jsonObj){\n    jsonContent = jsonObj;\n    container = $(\"#\"+divID);\n    av = new JSAV(document.getElementById(divID));   \n}\n\n\n//this is the main function, animation starts here\nvizJSAV.prototype.animate = function(statementNo){\n    var statementLabel =\"statement_\"+statementNo;\n    currentStat = statementLabel;\n    current_content = jsonContent[statementLabel][\"current_content\"];\n    current_line = jsonContent[statementLabel][\"current_line\"];\n\n    if (!(statementLabel in jsonContent)){\n        return;// out of statement range\n    }\n    \n    var depthList = jsonContent[statementLabel][\"vars\"];\n\n    //create or hide layer\n    var layerCount = Object.keys(depthList).length;\n\n    //add layer\n    for (var i = 0; i < layerCount; i++) {\n        var layer = $(\"<div id='layer\"+(i+1)+\"' class='graphlayer'><span>Data structures: </span></div>\");\n        container.append(layer);\n        var avObj = new JSAV(layer);\n\n        avDepthDict[\"depth_\" + (i + 1)] = avObj;\n        divDepthList[i] = layer;\n\n    }\n\n    //reset the width of layer div\n    var containerWidth = container.width()\n        padding = 10, //padding-left:30, padding-right: 30, otherwise pointer may be out of border\n        singleLayerWidth = (containerWidth-(2*padding*layerCount))/layerCount;\n    $(\".graphlayer\").css(\"width\", singleLayerWidth);\n    $(\".graphlayer\").css(\"padding-left\", padding);\n    $(\".graphlayer\").css(\"padding-right\", padding);\n\n    \n    \n    //start plotting the new variables\n    for (var depth in depthList){\n        var variableList = depthList[depth];\n        for (var j=0; j<variableList.length; j++){\n             var variable = variableList[j];\n             if (variable != null){\n                var varName = variable.name;\n                av = avDepthDict[depth];\n\n                this.plotVar(variable, depth);\n             }\n         }\n    }\n};\n\n/***************************************Plot one variable********************************************/\nvizJSAV.prototype.plotVar = function(variable, depth){\n\n    //varFlags could be null or 1 or 2\n    var varType = variable.type,\n        varName = variable.name,\n        varValue = variable.value,\n        avVar,\n        avLabel;\n\n    //If type is None, ignore. (None is not NoneType)\n    switch (varType){\n        case \"int\": case \"str\": case \"bool\":case \"float\":case \"NoneType\":\n            var statusStr = varType + \"(\" + varName.trim() +\"): \" + varValue;\n            avVar = av.code(statusStr, {lineNumbers: false});\n            avVar.addClass(\"primitive\");\n            break;\n\n        case \"Dict\":\n            avLabel = av.label(variable.name);\n            avVar = this.parseDict(variable);\n            avVar.addClass(\"Dict\"); \n            break;\n\n        case \"DisjointSet\":\n            avLabel = av.label(variable.name);\n            avVar = this.parseDisjointSet(variable);\n            avVar.addClass(\"DisjointSet\");\n            break;\n\n        case \"Array\":\n            avLabel = av.label(variable.name);\n            avVar= this.parseList(variable, {});\n            avVar.addClass(\"Array\");\n            break;\n\n        case \"Stack\":\n            avLabel = av.label(variable.name);\n            avVar = this.parseList(variable, {layout: \"vertical\", indexed: true});\n            avVar.addClass(\"Stack\");\n            break;\n\n        case \"Queue\":\n            avLabel = av.label(variable.name);\n            avVar= this.parseList(variable, {indexed: true});\n            avVar.addClass(\"Queue\");\n            break;\n\n        case \"LinkedList\":\n            avLabel = av.label(variable.name);\n            avVar= this.parseLinkedList(variable);\n            avVar.addClass(\"LinkedList\");\n            break;\n\n        case \"BinaryMinHeap\": case \"BinaryMaxHeap\":\n            avLabel = av.label(variable.name);\n            avVar = this.parseHeap(variable);\n            avVar.addClass(\"BinaryHeap\");\n            break;\n\n\n        case \"MinPriorityQueue\": case \"MaxPriorityQueue\":\n            avLabel = av.label(variable.name);\n            avVar = this.parseHeap(variable);\n            avVar.addClass(\"PriorityQueue\");\n            break;\n      \n        case \"Tree\":\n            avLabel = av.label(variable.name);\n            avVar = this.parseTree(variable);\n            avVar.addClass(\"Tree\");\n            break;\n      \n        case \"BinarySearchTree\":\n            avLabel = av.label(variable.name);\n            avVar = this.parseBTree(variable, \"BinarySearchTree\");\n            avVar.addClass(\"BinarySearchTree\");\n            break;            \n\n        case \"AVLTree\":\n            avLabel = av.label(variable.name);\n            avVar = this.parseBTree(variable, \"AVLTree\");\n            avVar.addClass(\"AVLTree\");\n            break;\n\n        case \"RBTree\":\n            avLabel = av.label(variable.name);\n            avVar = this.parseBTree(variable, \"RBTree\");\n            avVar.addClass(\"RBTree\");\n            break;\n\n        case \"Graph\":\n            avLabel = av.label(variable.name);\n            avVar = this.parseGraph(variable, {layout: \"layered\"});\n            avVar.addClass(\"Graph\");\n            break;\n\n        case \"DiGraph\":\n            avLabel = av.label(variable.name);\n            avVar = this.parseGraph(variable, {directed: true, layout: \"layered\"});\n            avVar.addClass(\"DiGraph\");\n            break;\n   \n        case \"Matrix\":\n            avLabel = av.label(variable.name);\n            avVar= this.parseMatrix(variable);\n            avVar.addClass(\"Matrix\");\n            break;\n        case \"StringMatrix\":\n            avLabel = av.label(variable.name);\n            avVar= this.parseStringMatrix(variable);\n            avVar.addClass(\"StringMatrix\");\n            break;\n        \n        case \"None\":\n            break;\n        default:\n            break;\n    }\n};\n\nvizJSAV.prototype.parseDict=function(variable){\n    var valDict=variable.value;\n\n    var nCols = valDict.length;\n    var nRows = 2;\n\n    var matrix = new Array();\n    var firstRow = new Array(\"Key\");\n    var secondRow = new Array(\"Val\");\n    var count = 1;\n    for(var key in valDict){\n        firstRow.push(key);\n        secondRow.push(valDict[key]);\n    }\n\n    matrix.push(firstRow);\n    matrix.push(secondRow);\n\n    var avVar = av.ds.matrix(matrix);\n    avVar.mouseenter(avVar.highlight).mouseleave(avVar.unhighlight);\n\n    return avVar;\n};\n\nvizJSAV.prototype.parseDisjointSet=function(variable){\n\n    var tree = av.ds.tree();\n    var valDict = variable.value,\n        nodeDict = {};\n\n    //First add a invisible root node\n    var root = tree.root();\n    root.hide({\"recursive\": false});\n\n    for (var key in valDict){\n        var value = valDict[key];\n        if (!(key in nodeDict)){\n            var newNode = tree.newNode(key);\n            nodeDict[key] = newNode;\n        }\n        if (!(value in nodeDict)){\n            var newNode = tree.newNode(value);\n            nodeDict[value] = newNode;\n        }\n\n        if (key == value){ // independent set\n            root.addChild(nodeDict[key]);\n            //hide the edge to root\n            nodeDict[key].edgeToParent().hide();\n        }else{\n            nodeDict[value].addChild(nodeDict[key]);\n        }\n    }\n    tree.layout();\n    tree.mouseenter(function() {\n        this.highlight(); \n    }).mouseleave(function() { \n        this.unhighlight(); \n    });\n    return tree;\n};\n\nvizJSAV.prototype.parseList=function(variable, options) {\n    var valueList = variable.value;\n\n    var avVar = av.ds.array(valueList, options);//TODO: to support multi-dimensional array, split based on brackets stack is needed.Changes on compiler flags array is also required.\n    avVar.mouseenter(avVar.highlight).mouseleave(avVar.unhighlight);\n    return avVar;\n};\n\nvizJSAV.prototype.parseLinkedList=function(variable){\n    var valList = variable.value,\n        varName = variable.name;\n\n    var avVar = av.ds.list();\n\n    for (var i=0; i<valList.length; i++){\n        avVar.addLast(valList[i]);\n    }\n\n    avVar.layout();\n    avVar.mouseenter(function() {\n        this.highlight(); \n    }).mouseleave(function() { \n        this.unhighlight(); \n    });\n\n    return avVar;\n};\n\n//complete binary tree\nvizJSAV.prototype.parseHeap=function(variable){\n    var tree = av.ds.binarytree();\n    var valArr = variable.value,\n        nodeList = [];\n\n    for (var i=0; i<valArr.length; i++){\n        var newNode = tree.newNode(valArr[i]);\n        nodeList.push(newNode);\n\n        if (i == 0){\n            tree.root(newNode);\n        }else{\n            var parentIndex = parseInt((i-1)/2);\n            if (i%2 == 0){//right node\n                nodeList[parentIndex].right(newNode);\n            }else{//left node\n                nodeList[parentIndex].left(newNode);\n            }\n        }\n    }\n\n    tree.mouseenter(function() {\n        this.highlight(); \n    }).mouseleave(function() { \n        this.unhighlight(); \n    });\n\n    tree.layout();\n    return tree;\n};\n\n//Tree\nvizJSAV.prototype.parseTree=function(variable){\n    var tree = av.ds.tree();\n    var varValue = variable.value;\n\n    var optStack = [];\n    var nodeStack = [];\n\n    //[42[25][76][31][85][82][26][28][99][32]]\n    for (var i=0; i<varValue.length;i++){\n\n        switch(varValue[i]){\n            case '[':\n                optStack.push('[')\n                //search until next [ or ]\n                i++;\n                var token = \"\"\n                while(varValue[i]!='[' && varValue[i]!=']' && i<varValue.length){\n                   token=token+varValue[i];\n                   i=i+1;\n                }\n                i--;\n                var newNode = tree.newNode(token.trim());\n                nodeStack.push(newNode)\n                break;\n            case ']':\n                optStack.pop();\n                var node = nodeStack.pop();\n                if (nodeStack.length == 0){\n                    tree.root(node);\n                } else {\n                    var parentNode = nodeStack[nodeStack.length-1];\n                    parentNode.addChild(node);\n                }\n            default:\n                break;\n\n        };\n\n    }\n\n    tree.mouseenter(function() {\n        this.highlight(); \n    }).mouseleave(function() { \n        this.unhighlight(); \n    });\n\n    tree.layout();\n    return tree;\n\n};\n\nvizJSAV.prototype.parseBTree=function(variable, treeType){\n    var tree = av.ds.binarytree();\n    var varValue = variable.value,\n        rbValue = variable.color;\n        \n    var rbArr;\n    if (treeType == \"RBTree\"){\n        rbArr = rbValue.replace(/\\[/g,\" \").replace(/\\]/g,\" \").match(/\\S+/g); //split by space\n    }\n\n    var optStack = [];\n    var nodeStack = [];\n    var token = \"\";\n    var node;\n    var str = varValue;\n    var tempLast;\n    var nodeCount = 0;\n    for (var i=0; i<str.length;i++){\n        switch(str[i]){\n            //[9[8][10]]\n            case '[':\n                optStack.push(str[i]);\n                //alert(\"new node start!\");\n                break;\n            case ']':\n                //alert(\"a node closed!\");\n                optStack.pop();\n                if (optStack.length==0){\n                    node=nodeStack.pop();\n                    tree.root(node);\n                    //alert(node.value());\n                }else{\n                    node=nodeStack.pop();\n                    if (node == null){\n                        continue;\n                    }\n                    //alert(node.value());\n                    tempLast=nodeStack.length-1;\n\n                    if (parseInt(node.value())<parseInt(nodeStack[tempLast].value())){ //without parseint 10 < 9\n                        nodeStack[tempLast].left(node);\n                    }else{\n                        nodeStack[tempLast].right(node);\n                    }\n                }\n                break;\n            default:\n                while(str[i]!='[' && str[i]!=']' && i<str.length){\n                   token=token+str[i];\n                   i=i+1;\n                }\n                token = token.trim().replace(/\\'/g, \"\").replace(/\\\"/g, \"\");\n                if (token!=\"None\"){\n                    node = tree.newNode(token);\n                    if (treeType == \"RBTree\"){\n                        if (rbArr[nodeCount] == \"R\"){\n                            node.css({\"background-color\": graphColor[\"RED\"]});\n                        }else if(rbArr[nodeCount] == \"B\"){\n                            node.css({\"color\":\"white\",\"background-color\": \"BLACK\"});\n                        }\n                    }\n\n                    nodeStack.push(node);\n                    //alert(node.value()+\" is created!\");\n                }else{\n                    nodeStack.push(null);\n                }\n                nodeCount++;\n                token=\"\";//reset token\n                i=i-1;//reset i\n                break;\n        }\n    }\n    tree.layout();\n    return tree;\n};\n\nvizJSAV.prototype.parseGraph=function(variable, options){\n    var vertexList = variable.V,\n        edgeList = variable.E;\n\n    var graph = av.ds.graph(options);\n\n    //Add nodes to graph\n    var vertexDict = {};\n    for(var i=0; i<vertexList.length; i++){\n        var vertex = vertexList[i].value,\n            color = vertexList[i].color.toUpperCase();\n        var node = graph.addNode(vertex);\n        node.css({\"background-color\": graphColor[color]});//change color depth, if not find in the dictionary, default is white\n        vertexDict[vertex] = node;\n    }\n\n    //Add edges to graph\n    for (var i=0; i<edgeList.length; i++){\n        var start = edgeList[i].start,\n            end = edgeList[i].end,\n            color = edgeList[i].color,\n            weight = edgeList[i].weight;\n        graph.addEdge(vertexDict[start], vertexDict[end], {\"weight\": weight, \"stroke\": color});\n    }\n\n    graph.layout();\n    return graph;\n};\n\nvizJSAV.prototype.parseMatrix = function(variable){\n    //no flags for matrix\n    var matrixName = variable.name,\n        matrixArr =variable.value;\n\n    var avVar = av.ds.matrix(matrixArr, {style: \"matrix\"});\n    avVar.layout();\n    return avVar;\n};\n\nvizJSAV.prototype.parseStringMatrix=function(variable){\n    var matrixArr = variable.value,\n        edgesArr = variable.edges,\n        topheaderObj = $.extend(true, {}, variable.topheader),\n        leftheaderObj = $.extend(true, {}, variable.leftheader);\n\n    //deepcopy topHeader\n    var topheader = $.map(topheaderObj, function(value, index) {\n        return [value];\n    });\n\n    //deepcopy leftHeader\n    var leftheader = $.map(leftheaderObj, function(value, index) {\n        return [value];\n    });\n\n\n    var hasHeader = (topheader.length != 0 || leftheader.length != 0); //topheader changed below, this will cause topheader != [] true here.\n\n    //var newMatrixArr = matrixArr;//matrix array with headers, need to use deepcopy here, otherwise it will change the variable value\n    var newMatrixObj = $.extend(true, {}, matrixArr);//deep copy returns a dict object, need to convert to array\n    var newMatrixArr = $.map(newMatrixObj, function(value, index) {\n        return [value];\n    });\n\n    if (hasHeader){\n        //unshift or splice, both are ok\n\n        ////if topheader length != cols, append empty strings to it\n        //for (var i=topheader.length; i<newMatrixArr[0].length; i++){\n        //    topheader[i] = \"\";\n        //}\n        //newMatrixArr.unshift(topheader);//add to the front\n        ////add left header line by line\n        //newMatrixArr[0].unshift(\"\");//top-left corner should be empty\n        //\n        //for (var i=1; i<newMatrixArr.length; i++){\n        //    newMatrixArr[i].unshift(leftheader[i-1]); //if leftheader[i-1] is undefined, the program will simply leave that cell blank\n        //}\n\n        //if topheader length != cols, add empty strings to the front\n        for (var i=topheader.length; i<newMatrixArr[0].length; i++){\n            topheader.splice(0,0, \"\");\n        }\n        for (var i=leftheader.length; i<newMatrixArr.length; i++){\n            leftheader.splice(0,0, \"\");\n        }\n        newMatrixArr.splice(0,0,topheader);//add to the front\n        //add left header line by line\n        newMatrixArr[0].splice(0, 0, \"\");//top-left corner should be empty\n\n        for (var i=1; i<newMatrixArr.length; i++){\n            newMatrixArr[i].splice(0,0,leftheader[i-1]); //if leftheader[i-1] is undefined, the program will simply leave that cell blank\n        }\n\n    }\n\n    var avVar = av.ds.matrix(newMatrixArr, {style: \"plain\"});\n\n    //gray the header\n    if (hasHeader){\n        for (var i=1; i<newMatrixArr[0].length; i++){\n            avVar.css(0, i, {\"background-color\": matrixHeaderColor});\n        }\n        for (var i=1; i<newMatrixArr.length; i++){\n            avVar.css(i, 0, {\"background-color\": matrixHeaderColor});\n        }\n    }\n\n    //Add edges\n    for (var i=0; i<edgesArr.length; i++){\n        //addEdge(a,b,c,d), if one of the node is flag c or n, change edge color\n        var a = parseInt(edgesArr[i][0]),\n            b = parseInt(edgesArr[i][1]),\n            c = parseInt(edgesArr[i][2]),\n            d = parseInt(edgesArr[i][3]),\n            opts = {};\n        if (hasHeader){\n            a++; b++; c++; d++;\n        }\n\n        avVar.addEdge(a,b,c,d,opts);\n    }\n\n    avVar.layout();\n    return avVar;\n};\n"],"sourceRoot":"/source/"}